<channel><title></title><description></description><link>/<generator>Ghost 0.10</generator><lastbuilddate>Wed, 15 Feb 2017 15:35:18 GMT</lastbuilddate><link href="/rss/" rel="self" type="application/rss+xml"><ttl>60</ttl><item><title></title><description>SharePoint REST API is nice, powerful and universal to deal with, but sometimes you face barriers and recall that the desired API is absent in REST yet at the same time is a part of CSOM/JSOM. It's not an issue when your code lives in a context of a]]&gt;</description><link>/2017/02/15/working-with-sharepoint-mmd-in-node-js/<guid ispermalink="false">648aa6f7-ebd5-4810-8100-a9f35e6a1ee4</guid><category></category><category></category><category></category><category></category><category></category><category></category><creator></creator><pubdate>Wed, 15 Feb 2017 15:15:54 GMT</pubdate><content url="/content/images/2017/02/SharePoint-MMD-Screwdriver.png" medium="image"></content><encoded><p>SharePoint REST API is nice, powerful and universal to deal with, but sometimes you face barriers and recall that the desired API is absent in REST yet at the same time is a part of CSOM/JSOM. It's not an issue when your code lives in a context of a page, but what if not? C# CSOM probably will be the most obvious answer. But what if you're limited with the choice of used language or a runtime environment and .Net is not an option?</p>

<p>In a context of this story, the limitations are Node.js and JavaScript. And the task is to have a basic layer of functionality to deal with Managed Metadata (Taxonomy), such as:</p>

<ul>
<li>Get child terms in a term set</li>
<li>Get child terms in a parent term</li>
<li>Get a specific term</li>
<li>Add new term</li>
<li>Update a term</li>
<li>Deprecate a term</li>
<li>Get all terms (for relatively small dictionaries)</li>
<li>...</li>
</ul>

<p>The easiest solution for some basic methods will be SOAP services. Yes, SOAP services are deprecated in SharePoint and they smell like mammoth fossils. But still there and working.</p>

<p>There is a SOAP service to work with MMD <code>/_vti_bin/TaxonomyClientService.asmx</code>. Let's take a look at it. The service represents the following methods:</p>

<ul>
<li>AddTerms</li>
<li>GetChildTermsInTerm</li>
<li>GetChildTermsInTermSet</li>
<li>GetKeywordTermsByGuids</li>
<li>GetTermSets</li>
<li>GetTermsByLabel</li>
</ul>

<p>To consume these in Node.js you can use almost any http request module with encapsulation of auth cookie to the request headers. Likely all these authentication and even the libraries, specific for SharePoint requests, are created and here for our disposal, abstracting scary moments from away. I'm describing <a href="https://github.com/s-KaiNet/sp-request">sp-request</a> with <a href="https://github.com/s-KaiNet/node-sp-auth">node-sp-auth</a>.</p>

<p>One can easily talk to SharePoint SOAP service with use of <code>sp-request</code> like this:</p>

<pre><code class="language-javascript">const baseUrl = 'https://contoso.sharepoint.com/sites/site';  
let authObject = { ... }; // node-sp-auth authentication format  
let request = require('sp-request').create(authObject);  
let headers = {};

let soapBody = `  
   ... // XML SOAP body for a specific method
`;

headers['Accept'] = 'application/xml, text/xml, */*; q=0.01';  
headers['Content-Type'] = 'text/xml;charset=\"UTF-8\"';  
headers['X-Requested-With'] = 'XMLHttpRequest';  
headers['Content-Length'] = soapBody.length;

request.post(baseUrl + '/_vti_bin/TaxonomyClientService.asmx', {  
  headers: headers,
  body: soapBody,
  json: false
})
  .then(response =&gt; {
    // Proceed the responce object
  })
  .catch(err =&gt; console.log(err));
</code></pre>

<p>Figuring out with SOAP body for some methods can sometimes be tricky as SOAP operations descriptions miss some important parts, but any blog posts related to SP SOAP services also are relevant for Node.js use cases.</p>

<p>I wrapped some methods in an open source library <a href="https://github.com/koltyakov/sp-screwdriver">sp-screwdriver</a>. It's not for production purposes, yet can be a start point or example how to consume the methods.</p>

<p>Here we're standing in front another wall, those SOAP interfaces are sometimes featureless and offer only a limited number of actions. What about editing existing terms, how to request all them in a single request?</p>

<p>Here I use a little hack, which includes the following workflow:</p>

<ul>
<li>Create the desired activity in JSOM</li>
<li>Run it in the browser monitoring actual requests in fiddler </li>
<li>Parse actual package generated and sent to <code>/_vti_bin/client.svc/ProcessQuery</code></li>
<li>Recreate the package for reusability and wrap inside a Node.js method</li>
</ul>

<p>For example, request to set term name in the end looks like:</p>

<pre><code class="language-xml">&lt;Request xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"  
      SchemaVersion="15.0.0.0" LibraryVersion="15.0.0.0" 
      ApplicationName="Javascript Library"&gt;
    &lt;Actions&gt;
        &lt;SetProperty Id="166" ObjectPathId="157" Name="Name"&gt;
            &lt;Parameter Type="String"&gt;{{ newName }}&lt;/Parameter&gt;
        &lt;/SetProperty&gt;
    &lt;/Actions&gt;
    &lt;ObjectPaths&gt;
        &lt;StaticMethod Id="146" 
           Name="GetTaxonomySession" 
           TypeId="{981cbc68-9edc-4f8d-872f-71146fcbb84f}" /&gt;
        &lt;Property Id="149" ParentId="146" Name="TermStores" /&gt;
        &lt;Method Id="151" ParentId="149" Name="GetByName"&gt;
            &lt;Parameters&gt;
                &lt;Parameter Type="String"&gt;{{ serviceName }}&lt;/Parameter&gt;
            &lt;/Parameters&gt;
        &lt;/Method&gt;
        &lt;Method Id="154" ParentId="151" Name="GetTermSet"&gt;
            &lt;Parameters&gt;
                &lt;Parameter Type="String"&gt;{{ termSetId }}&lt;/Parameter&gt;
            &lt;/Parameters&gt;
        &lt;/Method&gt;
        &lt;Method Id="157" ParentId="154" Name="GetTerm"&gt;
            &lt;Parameters&gt;
                &lt;Parameter Type="String"&gt;{{ termId }}&lt;/Parameter&gt;
            &lt;/Parameters&gt;
        &lt;/Method&gt;
    &lt;/ObjectPaths&gt;
&lt;/Request&gt;  
</code></pre>

<p>Some comments about the format:</p>

<ul>
<li>Schema version is changed to <code>15.0.0.0</code> to support On-Premises SharePoint, at the same time it works in SPO.</li>
<li>Some redundant tags can be deleted from the original package received in fiddler, by looking at a package it's almost clear from the start what is redundant.</li>
<li>IDs represent the flow or chain and project the sequence. They are different from request  to request, but if to freeze them static and request again and again it just work. So I decided to leave them static.</li>
<li>Parameters in {{ doubleCurlyBraces }} is a dynamic part, they replaced in runtime with actual values by JS code. Package for sure should not include any {{ }}.</li>
</ul>

<p>getAllTerms, setTermName and deprecateTerm example wrappers can be seen in <a href="https://github.com/koltyakov/sp-screwdriver/blob/master/src/api/mmd.js">sp-screwdriver</a> too.</p>

<p>After the wrapper methods are implemented, Node.js receives a capability to run a request like:</p>

<pre><code class="language-javascript">let Screwdriver = require('sp-scredriver');  
let context = require('./path_to_private_settings');  
let screw = new Screwdriver(context);

let data = {  
    baseUrl: context.siteUrl,
    serviceName: config.mmd.serviceName,
    termSetId: config.mmd.termSetId,
    properties: [
        'Id', 'Name', 'Description', 'CustomProperties',
        'IsRoot', 'IsDeprecated', 'PathOfTerm',
        'IsAvailableForTagging', 'Parent'
    ]
};

screw.mmd.getAllTerms(data)  
    .then(response =&gt; {
        let results = JSON.parse(response.body);
        console.log("Response:", results);
    })
    .catch(err =&gt; console.log('Error:', err.message));
</code></pre>

<p>For myself, it was a nice way extending Node.js solutions capabilities. Such approach was applied on a couple of projects in Web Jobs, proceeding some information in SharePoint including MMD which was used as a part of architecture in the host solution.</p>

<p>Also, working with MMD directly within Node.js code was viable in an Electron application, we implement recently.</p>

<p>It's a not a single try to say that the same should not be done in .Net, actually it should, but, at the same time, there are cases of Node.js usage scenarios and it's nice to be able to extend it to consume not only the REST API, but potentially any CSOM/JSOM functionality. </p>]]&gt;</encoded></item><item><title></title><description>We're getting used to modern SharePoint (client side) development day by day. It transforms into some sort of a hybrid of Visual Studio Code'ing, Gulp tasks, and Chrome Dev Tools debugging and tweaks.

<p>More and more features from the funky front-end development are here at our disposal. Yet, there was</p>]]&gt;</description><link>/2016/11/05/sharepoint-client-side-development-with-live-reload/<guid ispermalink="false">e3276611-dc06-42b9-9a01-5e695e111cd6</guid><category></category><category></category><category></category><category></category><category></category><creator></creator><pubdate>Fri, 04 Nov 2016 23:44:19 GMT</pubdate><content url="/content/images/2016/11/SharePointLiveReload.png" medium="image"></content><encoded><p>We're getting used to modern SharePoint (client side) development day by day. It transforms into some sort of a hybrid of Visual Studio Code'ing, Gulp tasks, and Chrome Dev Tools debugging and tweaks.</p>

<p>More and more features from the funky front-end development are here at our disposal. Yet, there was one which has been missed and desired by some engineers. You might have heard about BrowserSync, have you? It is a module which can be injected into the page(s) and watches for changes for instantaneous page reload or scripts reload. A developer saves a file in the editor and sees the result applied right away.</p>

<p>As we know, SharePoint has its nuances, which prevents BrowserSync from efficient working. Luckily there is an alternative now.</p>

<p>Recently I've wrapped up the technique we have been using in our team for last months into the NPM module - <a href="https://github.com/koltyakov/sp-live-reload">sp-live-reload</a>.</p>

<p>With <code>sp-live-reload</code> it's possible to save a local client side file, such as javascript, css, html (source for content editor web part) with immediate change in open browsers tabs without a necessity for manual page refresh:</p>

<p><img src="http://koltyakov.ru/images/LiveReloadSimpleDemo.gif" alt="SharePoint client side development with Live Reload"></p>

<p>To make it work a developer can install the module with use of NPM command:</p>

<pre><code class="language-bash">npm install sp-live-reload --save-dev  
</code></pre>

<p>And then use the live reload in Gulp tasks as shown in examples on the project page.</p>

<p>We use it in the combination with <a href="http://github.com/s-KaiNet/gulp-spsave">SPSave</a>, the module which makes files upload and publishing to SharePoint transparent. Any <a href="http://github.com/koltyakov/sp-live-reload#watch-with-live-reload-gulp-spsync">alternatives</a> will work as well if emitted to the client path is correct.</p>

<pre><code class="language-javascript">var gulp = require('gulp');  
var spsave = require("gulp-spsave");  
var watch = require('gulp-watch');  
var through = require('through2');  
var LiveReload = require('sp-live-reload');

var config = require('./gulp.config');

gulp.task("watch-assets", function () {  
    console.log("Watch with reload is initiated.");
    console.log("Make sure that monitoring script is provisioned to SharePoint.");
    var liveReload = new LiveReload(config);
    liveReload.runServer();
    return watch(config.watchAssets, function (event) {
        console.log(event.path);
        gulp.src(event.path, {
            base: config.watchBase
        }).pipe(spsave(config.spsaveCoreOptions, config.spsaveCreds))
        .pipe(through.obj(function (chunk, enc, cb) {
            var chunkPath = chunk.path;
            liveReload.emitUpdatedPath(chunkPath);
            cb(null, chunk);
        }));
    });
});
</code></pre>

<p>The most controversial moment is how to deliver a live reload client script to SharePoint. Some possible issues are connected with that. As the environment can be shared between different persons.</p>

<p>There are following assumptions taken in mind:</p>

<ul>
<li>Live reload is actual in a development environment (less on a test, and almost never on the production)</li>
<li>There are limited developers on a specific development environment to conflict with each other</li>
<li>There is a variety of different browsers which should be supported by the reloading module</li>
</ul>

<p>With this being said, let me describe the approach:</p>

<ul>
<li>There are two options for delivering live reload client script to SharePoint:
<ul><li>Manual, when watch task is running it provides a URL to the script</li>
<li>Automated, a special gulp task exists for provisioning user custom action with script source </li></ul></li>
<li>Live reload script references for a localhost running server to receive information about updates, a developer who aren't running live reload task and doing something in the console just see one 404 error for a page load (this bothers me a bit, but it's possible to live with that)</li>
<li>Custom action can be easily retracted with another gulp task after the development session is finished to avoid any hassles</li>
<li>When two or more developers are "live watching" on the same site collection only one custom action is created, so all developers should share the same settings for the protocol and port, use default if possible</li>
</ul>

<p>A few words about the architectural implementation. Client and watch server use <a href="http://socket.io/">Socket.io</a> as a transport layer. All the browsers which are supported with Socket.io and SharePoint are automatically supported for live reload. <br>
The live reload server is running inside some watching task (gulp or other), on change and deliver events the server emits the message with the relative path for the resource in SharePoint which has been updated. <br>
The live reload client receives the messages from the server and checks if any resource is on the page. The client takes in mind SharePoint related features, like CEWP's source content. Also, there will be a support for a masterpage update and page layout update detection. As well as a community voice, as the module is extendable and open sourced.</p>

<p>Live reload works with On-Premises SharePoint installations (2016 and 2013) and SharePoint Online. Yet with SharePoint Online or any running over HTTPS some additional afford is needed to generate SSL certificate and add import it to trusted. But it worth it!</p>

<p><code>sp-live-reload</code> also is integrated into <a href="https://github.com/koltyakov/generator-sppp">generator-sppp</a> so you can use Yeoman generator to check it in action.</p>]]&gt;</encoded></item><item><title></title><description>I've been eschewed <a href="http://github.com/OfficeDev/PnP-JS-Core">PnP-JS-Core</a> for a long time and preferred to use JSOM or plain REST calls with the use of jQuery.ajax or SP.RequestExecutor. "Why do I need any wrappers or helpers for the API stuff which can be an additional point of failure?", I asked myself a]]&gt;</description><link>/2016/09/09/sharepoint-pnp-javascript-core-components-deserve-more-attention/<guid ispermalink="false">1f49b68e-5af0-433f-8028-7096a9ff76bc</guid><category></category><category></category><category></category><category></category><category></category><category></category><creator></creator><pubdate>Fri, 09 Sep 2016 12:04:00 GMT</pubdate><content url="/content/images/2016/09/PnP-JS-Core_banner-2.png" medium="image"></content><encoded><p>I've been eschewed <a href="http://github.com/OfficeDev/PnP-JS-Core">PnP-JS-Core</a> for a long time and preferred to use JSOM or plain REST calls with the use of jQuery.ajax or SP.RequestExecutor. "Why do I need any wrappers or helpers for the API stuff which can be an additional point of failure?", I asked myself a couple of times putting PnP-JS-Core aside from learning.</p>

<p>But there was an opportunity this week to dive into the library and estimate expediency of its usage on a next project. The first fresh glance at it created a new and rather a positive attitude. First of all, it is made with the toolchain I love, and there are so many familiar faces in its contributors group, I didn’t even know to be related to the project. That was a good sign so I started.</p>

<h2 id="whatisit">What is it</h2>

<p>PnP-JS-Core is a part of Office 365 Developer Patterns and Components for JavaScript’ing in SharePoint.</p>

<p>It is a wrapper over RESTful API and a bit more. PnP JS Core provides a fluent JS API simplifying REST calls to SharePoint API.</p>

<h2 id="stackproject">Stack &amp; Project</h2>

<p>Yes, it’s made with the use of all of that shiny technologies we use on the most modern web projects: JavaScript (TypeScript), Gulp, NPM, Typings, Git, Linting, Serve and cool automation. It’s easy to understand the project structure, logic and contribute.</p>

<p>It is not necessary to investigate the source, but a lot of questions can be solved by checking the code and <a href="http://github.com/OfficeDev/PnP/tree/dev/Samples/SharePoint.pnp-js-core">samples</a>. In the end, PnP-JS-Core is not something complex to learn at all.</p>

<h2 id="usage">Usage</h2>

<p>PnP-JS-Core can be <a href="http://github.com/OfficeDev/PnP-JS-Core/wiki/Install-and-Use">installed</a> with the use of NPM or Bower. The library can be used in TypeScript project or referenced as any other JS library and consumed on a page or browser console.</p>

<p>PnP-JS-Core uses fetch protocol and ES6 promises, that’s why to make it work in IE, polyfills got to be loaded first. It is important to note, otherwise, if this part in documentation was skipped, one would be wondering “What the heck, it doesn’t work in IE? What is that error message in the console, saying "'Headers' is undefined?"”. But keep calm, PnP works perfectly in IE and Edge with es-promise and fetch polyfills.</p>

<h2 id="syntax">Syntax</h2>

<p>PnP-JS-Core has a base object <code>pnp</code> in case of default TypeScript import and <code>$pnp</code> if there is a pnp.js reference on a page and you are writing plain JS in a console or Chrome snippets.</p>

<p>REST calls, with the use of the PnP, can be constructed via fluent API chains with a promise initiator at the end of the statement.</p>

<p>For example, let’s take some basic REST endpoint: <code>/_api/web/lists/getByTitle('CustomList')/items</code> call and reproduce it with the use of pnp:</p>

<pre><code class="language-javascript">$pnp.sp.web 
  .lists.getByTitle('ListTitle').items 
  .get() 
  .then(function(items) { 
    // all items are in the `items` array 
  });
</code></pre>

<p>$pnp.sp.web.lists.getByTitle('Custom01').items – is a constructor which builds endpoints URI.</p>

<p>IntelliSense helps during the process, so you can be even not aware of REST reference or at least have a bad memory and not necessarily remember the endpoints.</p>

<p>Yet, I highly recommend to have a strong understanding of <a href="http://msdn.microsoft.com/en-us/library/office/jj860569.aspx">REST API reference</a> and plan to receive all the fruits that PnP provide only after or use both during the learning curve of course.</p>

<p>When a fluent call is described, <code>get</code> method should be placed to initiate a query to a server. <code>Get</code> method and some others return a promise, that should be chained with <code>then</code> and <code>catch</code> to treat the results.  </p>

<p>Fluent API is really a piece of gold, all that <code>$select</code>, <code>$filter</code>, <code>$extend</code>, <code>$top</code>, etc. parameters are there as helper methods as well. The same is relevant for REST API properties and methods. But not everything is implemented in the current version. So it’s good to compare REST reference and PnP features if you feel like something is missing.</p>

<p>For example, I’ve found myself unable to get a list by its URL, which I accept as the only reasonable way to communicate with lists and libraries in the code (as display title can be changed anytime in the UI and GUIDs-based code is complex to maintain and is not reasonable too, as IDs will be different from deploy to deploy for the same business objects). But less than in a half an hour I managed to fork and implement <code>pnp.sp.web.getList</code> method representation for <code>/_api/web/getlist(‘/sites/site/web/list/name’)</code> and create a pull request for this.</p>

<p>That’s the power of open source.</p>

<h2 id="batches">Batches</h2>

<p>The well-known fact that REST API is very <code>chatty</code> (over the network) one. Sometimes JSOM’s pros argument over REST says that by queueing some OM queries definitions into one physical executeQueryAsync call you can make an application faster. That is definitely true. But did you know that REST also has such tricks in O365 and SharePoint 2016. That is /_api/$batch endpoint.</p>

<p>PnP provides a great simplification for batch REST queries. Any query can be placed in batch call and retrieved inside one single batch execute.</p>

<pre><code class="language-javascript">var batchResults = [];  
var batch = new $pnp.sp.createBatch();  
$pnp.sp.web.getList('/sites/dev01/lists/custom01').items.inBatch(batch).get().then(function(d) {
  batchResults.push({ 
    custom01: d 
  });
});
$pnp.sp.web.getList('/sites/dev01/lists/custom02').items.inBatch(batch).get().then(function(d) {
  batchResults.push({ 
    custom02: d 
  });
});
for (var i = 0, len = 10; i &lt; len; i += 1) {  
  $pnp.sp.web.getList('/sites/dev01/lists/custom03').inBatch(batch).items.add({ 
    Title: 'Item ' + i 
  });
}
batch.execute().then(function() {  
  console.log("All is done!", batchResults);
});
</code></pre>

<p>I was really surprised when discovered such a powerful and simple capability.</p>

<p>Unfortunately, REST batches aren’t supported in On-Prem versions before 2016 version.</p>

<h2 id="conclusion">Conclusion</h2>

<p>There was so much hype around PnP during last few years, but most people (developers or course), with whom I discussed PnP in general, never dived inside it at all, at the same time, were constantly mentioning it as a buzzword on different SP events.</p>

<p>At last, I’ve touched some part of the PnP projects from the JS world side personally and can say it louder that it is a very interesting library, it’s worth learning and I will definitely include it in the next UI project.</p>

<h3 id="upd">UPD:</h3>

<p>I've also tried PnP-JS-Core with <a href="http://github.com/koltyakov/sp-rest-proxy">sp-rest-proxy</a> and it works! :)</p>

<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAj0AAAAJGVhN2VkMDlmLWY0NDItNDVjYS05MTk5LWE1NjFiZWRiOWZhNg.png" alt="SharePoint PnP JavaScript Core Components – deserve more attention"></p>

<p>* This gonna work for GET calls only for now, due to the way sp-rest-proxy and pnp deal with Request Digest on a page.</p>]]&gt;</encoded></item><item><title></title><description>On the recent webcast dedicated to SharePoint Framework hosted by Rencore (SPFx Deep Dive Webinar on Wednesday, 31th of August) and driven by Bill Baer mostly, there were some interesting ideas, recommendations, and thoughts.

<p>As for me this "dive" was not so deep and actually looked more like SharePoint platform</p>]]&gt;</description><link>/2016/09/03/sharepoint-rest-api-proxy-for-local-serve-in-node-js/<guid ispermalink="false">734ab271-1b1e-450a-b1cf-5f4c31604dda</guid><category></category><category></category><category></category><category></category><category></category><category></category><category></category><creator></creator><pubdate>Sat, 03 Sep 2016 12:01:00 GMT</pubdate><content url="/content/images/2016/09/RestProxyExample-1.png" medium="image"></content><encoded><p>On the recent webcast dedicated to SharePoint Framework hosted by Rencore (SPFx Deep Dive Webinar on Wednesday, 31th of August) and driven by Bill Baer mostly, there were some interesting ideas, recommendations, and thoughts.</p>

<p>As for me this "dive" was not so deep and actually looked more like SharePoint platform history, toolchain overview and some scratching the surface showing a couple of the examples, but it's also a good stuff as timeframes were limited.</p>

<p>One of the coolest thing about SPFx is a capability to run <code>gulp serve</code>, after which you'll find yourself in local workbench ready to add client web parts on a modern page emulator and test them in action.</p>

<p><img src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAg0AAAAJDExYmQ1YjkzLWQ3YTItNGNjZC1iNzcxLWI4Mjg2OTUxNTQzMA.png" alt="SharePoint REST API proxy for local serve in Node.js"></p>

<p>One of the downsides of such local testing and debug is that you should deal with a mock generated artificial data. Maybe it only for now, maybe I understood incorrectly. But I consider that the real data is vital in many cases and real SharePoint API availability during such runtime can save hours of work and resolve tons of hassles.</p>

<p>I'm more than sure that later on real SharePoint API and data will be available locally within the workbench. This availability could be limited at least with REST API.</p>

<p>Why I'm so sure? Because it took me a single Friday night to create a REST API proxy with Node.js and Express, which allows running an application locally or on Node.js hosted server, which is actually the same, in other words, is not in the context of SharePoint page.</p>

<p>In such local web application page, without any deployment to SharePoint, one can execute GET or POST ajax call, let's say <code>/_api/web/lists</code>, which responses with the result as if an ajax call was on ShatePoint site page <code>~site/_api/web/lists</code>.</p>

<p><img src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAlYAAAAJGRiNjU3YjNjLWY0NzYtNDQxNS04ZTYzLWQ5NGQwNzBlOWExOA.png" alt="SharePoint REST API proxy for local serve in Node.js"></p>

<p>Any GET or POST call is routed to the real SharePoint tenant under specified user credentials, defined in the configuration of the proxy.</p>

<p><img src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAcrAAAAJGIwYzg2YTEzLTg5ZWUtNGZiNC1iMDY2LWE4MTMzNzQwNGU1MQ.png" alt="SharePoint REST API proxy for local serve in Node.js"></p>

<p>Of course, such proxy is limited with REST API only. It can be a complicated task to 're-implement' JSOM, for instance. But as far we go, more and more REST significance we see in SharePoint infrastructure as a universal and language agnostic technology.</p>

<p>The project I created is just a concept, you can <a href="https://github.com/koltyakov/sp-rest-proxy">check in on GitHub</a>. Will see what kind of power will be in SPFx for live communication with a SharePoint instance during workbench debug.</p>]]&gt;</encoded></item><item><title></title><description>This article is a continuation of my previous one (<a href="/2016/08/25/preparing-development-machine-for-client-side-sharepoint-projects-mac-and-pc/">Preparing development machine for client-side SharePoint projects</a>).

<p>I had stopped on a development machine with all necessary software installed and ready for coding.</p>

<p>And we’re almost ready, yet, we also desire to skip some scaffolding routines, because somebody did it</p>]]&gt;</description><link>/2016/08/30/front-end-sharepoint-projects-synced-and-safe/<guid ispermalink="false">a5af3ee5-f89f-421f-9cfb-620964eefe2a</guid><category></category><category></category><category></category><category></category><category></category><category></category><category></category><creator></creator><pubdate>Tue, 30 Aug 2016 11:57:00 GMT</pubdate><content url="/content/images/2016/09/YoSppp-1.png" medium="image"></content><encoded><p>This article is a continuation of my previous one (<a href="/2016/08/25/preparing-development-machine-for-client-side-sharepoint-projects-mac-and-pc/">Preparing development machine for client-side SharePoint projects</a>).</p>

<p>I had stopped on a development machine with all necessary software installed and ready for coding.</p>

<p>And we’re almost ready, yet, we also desire to skip some scaffolding routines, because somebody did it for us.</p>

<p>Have you heard about SharePoint Framework (aka SPFx)? What do they use for delivering project starting point? Yep, they use <a href="http://yeoman.io/">Yeoman generator</a>. But some might say “It’s too complex for me at the point”, “I have On-Premises with no Apps configured”, “I want just edit few assets” or “My project task is MasterPage-styling-related and I can’t achieve anything from SPFx yet”.</p>

<p>That’s why for the period of transition from old-style to something brighter, somebody created an alternative for you. Which is simpler to use, which allows mastering Git, VSC (or any), Node.js, tasks right now in a very straightforward way for a very simple but tremendously useful thing.</p>

<p>Here we are. We are going to use <a href="https://www.npmjs.com/package/generator-sppp">SP Pull-n-Push Yeoman Generator</a>. This generator creates a scaffolding project with tasks for pulling files from SharePoint library and saving changed assets to SharePoint back.</p>

<p>Yeoman and some other libraries should have been installed if you followed my previous post. Otherwise, just in case, the command:</p>

<pre><code class="language-bash">npm install -g gulp bower yo  
</code></pre>

<p>Let’s install generator next:</p>

<pre><code class="language-bash">npm install -g generator-sppp  
</code></pre>

<blockquote>
  <p>Note: SP Pull-n-Push is young, in case of issues or suggestions all the feedback is welcomed on <a href="https://github.com/koltyakov/generator-sppp/issues">GitHub</a>.</p>
</blockquote>

<p>On new version release Yeoman generators should be updated by running <code>yo</code> command in a console and selecting “Update your generators”, so you will be using fresh version while scaffolding your next assets project.</p>

<p>To scaffold a project you need to create (or better clone blank project from Git) and run <code>yo</code> command inside a project’s directory:</p>

<pre><code class="language-bash">yo sppp [YourProjectName]  
</code></pre>

<p>The generator’s wizard is executed right away. The wizard asks for project related questions, where you can provide all of the parameters, SharePoint site url and credentials.</p>

<p><img src="http://koltyakov.ru/images/generator-sppp-demo.gif" alt="Front-end SharePoint projects – synced and safe!"></p>

<p>All of the parameters could be changed later on in the project.</p>

<p>The wizard copies files and installs NPM and Bower component if needed.</p>

<p>In current version of this generator there are two tasks:</p>

<p>1. Downloading all the files from target folder in SharePoint to local project <code>./src</code> folder</p>

<p>This task can be useful in some cases. When we need to use existing assets as a start point and too lazy to copy them manually.</p>

<p>The second case is more advanced and consumes Git’s capability of detecting the changes. Imagine that some of the assets were changed and this change have been done outside the Git. That’s awful but happens. And we need to have a tool to run a task, wait a bit and see if it’s ok or if there are some potential issues.</p>

<p>For downloading all files from SharePoint <a href="https://www.npmjs.com/package/sppull">sppull</a> task is there.</p>

<pre><code class="language-bash">gulp sppull-all  
</code></pre>

<p>And, in a while, all the files from SharePoint target are delivered to a local directory for us.</p>

<p>2. The second task is for more often usage. Actually, it should be running everytime we are changing assets in a local project and expecting the changes to be applied to SharePoint.</p>

<pre><code class="language-bash">gulp watch-assets  
</code></pre>

<p>This task starts watching ./src folder and on any change uploads corresponding files straight to a destination. The task uses <a href="https://www.npmjs.com/package/gulp-spsave">gulp-spsave</a> module for Node.js integration with SharePoint.</p>

<p>A project created with the use of sppp yeoman generator could be extended with any other NPM or Bower dependencies and it could be the first step in diving to the new modern way of dealing with SharePoint and transition to SPFx.</p>]]&gt;</encoded></item><item><title></title><description>
  <p>This article is created and could be helpful for those who are planning to develop client-side SharePoint solutions using up-to-date tool sets</p>


<p>Let’s prepare our shiny new and naked development machine from scratch. We’re going to use package managers because they are the thing.</p>

<p>Initial installation is slightly</p>]]&gt;</description><link>/2016/08/25/preparing-development-machine-for-client-side-sharepoint-projects-mac-and-pc/<guid ispermalink="false">75433f8a-d597-46b3-b08a-b1979c3ea491</guid><category></category><category></category><category></category><category></category><category></category><category></category><category></category><category></category><creator></creator><pubdate>Thu, 25 Aug 2016 11:35:00 GMT</pubdate><content url="/content/images/2016/09/Environment-1.png" medium="image"></content><encoded>
  <img src="/content/images/2016/09/Environment-1.png" alt="Preparing development machine for client-side SharePoint projects (Mac and PC)"><p>This article is created and could be helpful for those who are planning to develop client-side SharePoint solutions using up-to-date tool sets</p>


<p>Let’s prepare our shiny new and naked development machine from scratch. We’re going to use package managers because they are the thing.</p>

<p>Initial installation is slightly different on OS X and Windows but the subsequent process of development and capabilities are the same.</p>

<h2 id="softtoinstall">Soft to install</h2>

<p>We need the following tools:</p>

<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a> – for ninja text editing</li>
<li>Chrome – if your developer position is in any way connected with the word “web” use this guy, there is nothing better than Chrome Dev Tools then you need to debug or tweak JS or CSS in browser</li>
<li><a href="https://nodejs.org/en/about/">Node.js</a> – it’s an engine and a heart of development workflow automation</li>
<li>Git client – for source control operations</li>
<li><a href="http://cmder.net/">Cmder</a> – splendid console emulator [for Windows] (Cmd could be used as well or Terminal on Mac OS)</li>
</ul>

<h2 id="windows">Windows</h2>

<h3 id="chocolatey">Chocolatey</h3>

<p>On a PC we’ll get the sugar out of <a href="https://chocolatey.org/">Chocolatey</a>, it’s a package manager for windows.</p>

<p>Chocolatey installation is as easy as run one-line command in CMD (run as administrator for sure):</p>

<pre><code class="language-bash">@powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" &amp;&amp; SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"
</code></pre>

<h3 id="packages">Packages</h3>

<p>Here are the benefits, to install all the soft you need it enough to run this (as administrator):</p>

<pre><code class="language-bash">choco install visualstudiocode googlechrome nodejs.install git.install cmder -y  
</code></pre>

<p>Now relax and take your favorite drink. Coffee in my case. =)</p>

<h2 id="osx">OS X</h2>

<h3 id="homebrew">Homebrew</h3>

<p>In a Mac world, <a href="http://brew.sh/">Homebrew</a> is responsible for the same stuff, it extends App Store, as its authors say “missing package manager”.</p>

<p>One-line command again in Terminal:</p>

<pre><code class="language-bash">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></pre>

<h3 id="packages">Packages</h3>

<p>Time saver is:</p>

<pre><code class="language-bash">brew install node git  
</code></pre>

<p>Unfortunately, there is no formula for Visual Studio Code or Chrome in Homebrew. Chrome could be installed via App Store. VSC has to be downloaded and installed <a href="https://code.visualstudio.com/Download">manually</a>, yet all of this won't take much time.</p>

<h2 id="nodeenvironment">Node environment</h2>

<p>Now we’re are ready to check the environment by requesting a version for node and its package manager (yeah, one more package manager, this one is used very often) and, of course, Git.</p>

<pre><code class="language-bash">node -v &amp;&amp; npm -v &amp;&amp; git --version  
</code></pre>

<p>This should return Node.js version, NPM version, then Git version each after another. Commands are combined together and could be split up.</p>

<p>Also, a good point is to check if the VSC is added to Path environment variable. The best option to check if is to navigate somewhere in your file system in the Console/Terminal and type (there should be a space between “code” and “dot”):</p>

<pre><code class="language-bash">code .  
</code></pre>

<p>VSC should run with a current folder, where we were in a console, opened.</p>

<p>Before you will be able to use NPM modules, project should be initiated by:</p>

<pre><code class="language-bash">npm init -y  
</code></pre>

<p>This will create package.json in your project folder. Package.json is a definition of the project.</p>

<h3 id="nodemodules">Node modules</h3>

<p>There is a variety of node modules. You can find thousands of them on <a href="https://www.npmjs.com/">NPM site</a>.</p>

<p>Some of the modules could be good, some of them not. So always check the author and community behind the module. As Node application is capable of anything on your machine double check before trust forever.</p>

<p>If you came from .Net world, NPM modules are just like NuGets but for the Node.js.</p>

<p>Modules can be installed globally and locally in the specific project.</p>

<h4 id="globalmodules">Global modules</h4>

<p>Global module installation example:</p>

<pre><code class="language-bash">npm install gulp -g  
</code></pre>

<p>Flag -g corresponds to “global”, without it installed module will be placed inside node_modules folder inside your project.</p>

<p>Modules that are better to install globally as they going to be used a lot in our projects are:</p>

<ul>
<li><a href="http://gulpjs.com/">gulp</a> – will automate your developer’s routine</li>
<li><a href="https://bower.io/">bower</a> – yet… oh, yet another package manager we need, this one delivers libraries which are used in a browser (such stuff as React, jQuery, Bootstrap, Knockout, well, all your favorite browser libraries)</li>
<li><a href="http://yeoman.io/">yeoman</a> – is a scaffolding tool for creating projects start point</li>
<li><a href="http://eslint.org/">eslint</a> – is a brilliant static code analyzer for JS</li>
<li>… let’s stop on that right now, don’t install too many modules until there is clear understanding why a specific module is needed
OK, so these can be installed with:</li>
</ul>

<pre><code class="language-bash">npm install gulp bower yo eslint -g  
</code></pre>

<h4 id="localmodules">Local modules</h4>

<p>Local modules are a part of your project, dependencies with easily delivering, updating, restoring, that make you reuse community’s efforts and abstract your application.</p>

<p>On most SharePoint assets or let’s say it UI development projects, you can benefit from:</p>

<ul>
<li>gulp – you might say “Stop it’s already installed globally”, but it also is needed locally (global installation allows to run “gulp [task]” in a console, but local installation makes it’s possible to use “require(‘gulp’)” in a code and define automation tasks)</li>
<li><a href="https://www.npmjs.com/package/spsave">spsave</a> or <a href="https://www.npmjs.com/package/gulp-spsave">gulp-spsave</a> – allow to publish files from local folders to SharePoint document libraries, so there is no need to deploy assets manually</li>
<li><a href="https://www.npmjs.com/package/sppull">sppull</a> – is responsible for downloading existing files from SharePoint programmatically to your project, so you can ensure easily if the project's assets files were changed somehow and have any differences with the Git HEAD using Git Diff algorithm </li>
<li>… any other modules depending on the tasks
Before going next, a few words about local modules installation save options.</li>
</ul>

<p>By installing something like:</p>

<pre><code class="language-bash">npm install sppull  
</code></pre>

<p>A module and all its dependencies will be downloaded to node_modules and you will be able to require it in the code, but one thing, if your project is in Git repository you might and should want to exclude modules folder from being stored in your repo.</p>

<p>But it’s weird to remember all the references then you clone a project from a remote Git repo, that’s why --save flag should be used.</p>

<p>So a dependency module installation looks like:</p>

<pre><code class="language-bash">npm install sp-request --save-dev  
</code></pre>

<p>--save-dev adds a module to development dependencies, --save – to production dependencies. The difference is following: --save-dev is applied when a module is used while code creation (it is the support libraries, all that gulp-* libs, sppull, spsave, they help to do stuff when you coding, but they are not included in the project app or dist assets that will be running in SharePoint). For SharePoint UI projects you likely won’t need any npm modules to save in prod.</p>

<p>If npm modules were installed with save option later on after cloning or pulling the project, you will need to run “npm install” and all the references will be downloaded and applied automatically.</p>

<h2 id="bowermodules">Bower modules</h2>

<p>Bower modules concepts and commands are very similar to NPM, the difference is that it manages browsers libraries. I’m not going to stop on Bower for long. Let’s check the command:</p>

<pre><code class="language-bash">bower install jquery#1.4.1 --save  
</code></pre>

<p>Isn’t it identical? In the case of jQuery I’m fetching a specific version I need, otherwise, the latest will be downloaded.</p>

<h2 id="git">Git</h2>

<p>Hey, folks! You know a lot about Git, don’t you? ;)</p>

<h2 id="finalsteps">Final steps</h2>

<ol>
<li>Create a project in Git (GitHub, BitBucket, Visual Studio Online, no matter)  </li>
<li>git clone [your<em>project</em>url]  </li>
<li>Navigate to your project directory  </li>
<li>NPM init/install: <br>
<ul><li>npm init -y – in the case if it is a new blank project</li>
<li>npm install – in the case of cloning already initiated project from Git
code .  </li></ul></li>
<li>... and, with VSC and console opened, you are ready to rock-n-roll</li>
</ol>

<p>Next time there will be a lot of code and config’s, I’ll describe project setup for instant publishing to SharePoint and fetching and merging files back from running instance. Hope all of this makes sense. Stay tuned. And welcome to the comment section below.</p>]]&gt;</encoded></item><item><title></title><description>Intro

<p>A lot of the SharePoint developers, in recent days, are switching from usual dev tools and workflows to something new, more universal and cross-platform. Please recall anything you have seen in modern MS-related video tutorials, how often have you seen OS X on a host’s machine? The answer</p>]]&gt;</description><link>/2016/08/22/modern-sharepoint-developer-tooling-stack/<guid ispermalink="false">c17fac23-9ee3-4738-8b72-7a90c178ee18</guid><category></category><category></category><category></category><category></category><category></category><category></category><category></category><creator></creator><pubdate>Mon, 22 Aug 2016 11:13:00 GMT</pubdate><content url="/content/images/2016/09/VSC.png" medium="image"></content><encoded>Intro

<img src="/content/images/2016/09/VSC.png" alt="Modern SharePoint Developer tooling stack"><p>A lot of the SharePoint developers, in recent days, are switching from usual dev tools and workflows to something new, more universal and cross-platform. Please recall anything you have seen in modern MS-related video tutorials, how often have you seen OS X on a host’s machine? The answer is likely to be “Very often”.</p>

<p>Soon you might probably forget about using legacy SharePoint Designer and Visual Studio for most cases. Of course, there will be always a place for Visual Studio, especially for code base provisioning and provided-hosted .Net stuff (no one has invented something better than <a href="https://github.com/SubPointSolutions/spmeta2">SPMeta2</a>, for example), but I can’t even recall when did I need to open SPD or VS for my daily development routine.</p>

<p>At the same time, due to my job, I have to write tons of code for SharePoint almost each day. And I prefer to avoid manual routines and automate my work as much as possible. The ideal scenario is “when I press Ctrl+S or Ctrl+B in my editor of choice I want to see changes immediately in a Dev environment”, you could add to this “immediate static code analysis and transpiling” and also “Git-connected-first approach”.</p>

<p>Yeah, I’m talking about front end part mostly. But not all the way, 20-30% is still something that I have to deploy on a server side, but this server side is actually a client side for SharePoint itself. So why don’t use the same Development tools stack for both too? Luckily it’s possible.</p>

<p>Now we’re switching to tooling of my choice.</p>

<h2 id="stacktools">Stack &amp; tools</h2>

<h3 id="languages">Languages</h3>

<p>As most of you have already understood, I’m going to mention JavaScript here. It’s not only ES5. Sometimes it can be ES2015 and Babel or TypeScript as a nice tool to avoid tons of issues, enhance your code and more.</p>

<p>I’m not even mentioning frameworks, it’s out of this topic. Just will say, yes you should definitely take advantage of frameworks that are your friends.</p>

<p>If there is a lot of styling in the project it reasonable to take advantages of stylesheet meta languages, I prefer Sass with Scss syntax.</p>

<h2 id="sourcecontrol">Source control</h2>

<p>I am confident that you all agree with me on this, Git is the best. I used TFVS before and will never go back.</p>

<h3 id="editors">Editors</h3>

<p>When code editors are discussed everyone has his or her own preference. I will strongly recommend taking a look at Visual Studio Code or VSC for short. It is lightning fast, has OOTB Git integration, really cool debugger (for a server-side JS) and with most of the plugins support. Alternatively, ATOM is great, but I use VSC for more than a year in my day to day work. It is awesome and its awesomeness is growing with each release. VSC team evolves their product nicely, I can’t say about some other MS products. ;)</p>

<h3 id="staticcodeanalysis">Static code analysis</h3>

<p>This one is must have for any project and team and… well… any coder in almost any situation. Yeah, really. I can’t bear without ESLint when writing JS (even with a compiler inside the brain, static analysis is the thing!) and TSLint in a case of TypeScript. Also, a good thing is to deploy linting tools globally to all team members. Just remember, it saves time and nervous.</p>

<p>It’s nice to have a linting tool as a plugin in an editor and also as a part of build process step.</p>

<h3 id="automatedtasks">Automated tasks</h3>

<p>I can’t see myself doing any project <code>larger to tiny</code> without the automated tasks in the background and on-demand. Gulp is a great choice for almost any case. Watching, linting, combining, uglifying, automated tests, publishing - all the stuff. If you are not familiar with Gulp and want to minimize your manual work I would recommend taking a look at it.</p>

<p>Some might prefer Webpack or Grunt. No problem they are also the great tools. My choice is Gulp as it is <code>code over config</code> and it has modules to work with SharePoint.</p>

<p>To achieve instant publishing, I use gulp watch and <a href="https://www.npmjs.com/package/gulp-spsave">gulp-spsave</a> module, which allows delivering local project files right to the SharePoint assets library with publish state and feeding the metadata, when needed.</p>

<h3 id="testing">Testing</h3>

<p>I’m not very good in testing but came to the understanding that automated testing is necessary, especially on the long-running projects. Right now I’m trying to implement unit testing on Mocha and the UI testing with use of Nightwatch (which uses Selenium drivers and written in JS) on some projects. Testing is a separate story as it’s not about tooling. One thing, if you have tests they definitely should be a part of your build process as a tool saving your time tremendously.</p>

<h3 id="packagemanagers">Package managers</h3>

<p>NPM for Node.js and Bower for browser libraries. I do not know what to add, they are straightforward and easy. Just use it! And never ever spend your time to go to vendor site to find, download and place a library to your project. Seriously, one line in a console and almost any library is delivered to your project.</p>

<p>Cross library references are also viable here. Especially when you have your private commercial super-duper library inside your private repo. Yet, it’s easy to reference to a library within the package using <code>git+[your_private_git_repo_url]#version</code>.</p>

<h3 id="nodejs">Node.js</h3>

<p>Oh, Node.js, it is outstanding and is a baseline for the tasks automation, package managers, most of the plugins and it’s opening the eyes to the fact that JS lives not only in the browser but also on the server or even a desktop application. Did you know that VSC is made using JS? But this is a completely different story.</p>

<h2 id="conclusion">Conclusion</h2>

<p>So we came to the end of the article.</p>

<p>Tools are very important. Sometimes how we do something could be at the first place over what we do. Right tools and techniques save our time, help to resolve potential issues.</p>

<p>In the world of SharePoint is also possible to use all that nice and shiny tools which are used in modern JavaScript world. As SharePoint is very close saying that JS is a number one technology for its customization. And we are the part of it.</p>

<p>Let’s combine: Git &lt;---&gt; VSC + Node.js + Gulp --&gt; SharePoint = happy coding!</p>]]&gt;</encoded></item></channel>
