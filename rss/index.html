<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[ARVO Systems Blog]]></title><description><![CDATA[SharePoint Development, Office 365, solutions in the cloud.]]></description><link>/</link><generator>Ghost 0.10</generator><lastBuildDate>Thu, 28 Jun 2018 14:37:32 GMT</lastBuildDate><atom:link href="/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Modern web parts provisioning in SharePoint Online]]></title><description><![CDATA[<html><head></head><body><p>Office 365 and SharePoint Online in particular rush in the direction of Modern UI and UX. The modern sites with modern pages have a number of advantages starting with simplicity for end users who manages the content and finishing with OOTB responsiveness and mobile friendliness. There is a bunch of</p></body></html>]]></description><link>/2018/06/28/modern-web-parts-provisioning-in-sharepoint-online/</link><guid isPermaLink="false">20f0d671-0675-473e-81f3-efb7f309fc4f</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[PnP]]></category><category><![CDATA[SPO]]></category><category><![CDATA[Provisioning]]></category><category><![CDATA[PowerShell]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Thu, 28 Jun 2018 14:03:51 GMT</pubDate><media:content url="/content/images/2018/06/modern-webparts-provisioning.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2018/06/modern-webparts-provisioning.png" alt="Modern web parts provisioning in SharePoint Online"><p>Office 365 and SharePoint Online in particular rush in the direction of Modern UI and UX. The modern sites with modern pages have a number of advantages starting with simplicity for end users who manages the content and finishing with OOTB responsiveness and mobile friendliness. There is a bunch of great web parts to use out of the shelf as well as a rich tooling and the framework for rapid development of custom ones. After a while, a question of modern sites managing and automated provisioning appears. In this post, I'm going to reveal and investigate some options for pages and web parts provisioning.</p>

<h2 id="modernpagestructurequickoverview">Modern page structure quick overview</h2>

<p>The modern page is a page in SitePages on a modern SharePoint site which provides a capability of organizing content within the page. A page can be configured with sections (rows), a section can be dynamically divided into columns or declared as a full-width section, then web parts can be added into a column. All of these gives a flexible way of managing the visual representation of information on the page.</p>

<h2 id="modernwebpartquickoverview">Modern web part quick overview</h2>

<p>Only modern web parts can be located on a modern page. Modern web parts can be separated to OOTB provided by Microsoft and custom 3rd party developed using SharePoint Framework (SPFx). OOTB web parts can't be changed, but all the web parts could be configured with properties defined during development time. Sometimes changing properties, one can receive absolutely different experience within the same web part.</p>

<p>Modern web parts are rendered on the pages as canvas controls, so "canvas control" is the second name for modern web parts.</p>

<p>Each web part has its own unique id, alias, version, manifest and data. The simplest way to research web parts' metadata is to add web parts you're interested in on the page, provide settings in the UI, publish the page and then add <code>?maintenancemode=true</code> parameter to the URL. This switches page into maintenance mode showing web parts' service information.</p>

<h2 id="provisioningoptions">Provisioning options</h2>

<p>Any developer in the wild should be equipped with provisioning toolchains. Only microscopic solutions should assume manual actions as a rule. I say this words as a mantra to the team members and customers. Depending on preferences and scenarios different approaches can be used for provisioning, but the process should be automated, point or even exclamation mark.</p>

<h3 id="pnpprovisioning">PnP provisioning</h3>

<p><a href="https://docs.microsoft.com/en-us/sharepoint/dev/solution-guidance/pnp-remote-provisioning">PnP provisioning</a> is a set of tools for .Net and PowerShell, which provides cutting edge feature capabilities when it comes to SharePoint Online.</p>

<p>PnP provisioning assumes two approaches: functional code-base provisioning and declarative schema-based processing. So, for example, one can provisiong an artifact using a specific PowerShell commandlet or .Net method or create an XML template based of a <a href="https://github.com/SharePoint/PnP-Provisioning-Schema/blob/master/ProvisioningSchema-2018-05.md">schema</a> and apply this template to site.</p>

<pre><code class="language-xml"><?xml version="1.0"?>
<pnp:Provisioning xmlns:pnp="http://schemas.dev.office.com/PnP/2018/05/ProvisioningSchema"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://schemas.dev.office.com/PnP/2018/05/ProvisioningSchema https://raw.githubusercontent.com/OfficeDev/PnP-Provisioning-Schema/master/OfficeDevPnP.ProvisioningSchema/ProvisioningSchema-2018-05.xsd">
  <pnp:Preferences Generator="OfficeDevPnP.Core, Version=2.26.1805.0, Culture=neutral, PublicKeyToken=5e633289e95c321a" />
  <pnp:Templates ID="PORTAL-PAGES-TEMPLATE">
    <pnp:ProvisioningTemplate ID="PAGES-TEMPLATE" Version="1.0">
      <pnp:ClientSidePages>
        <pnp:ClientSidePage PageName="SamplePage01.aspx" Title="Sample Page 01" Layout="Article" PromoteAsNewsArticle="false" Overwrite="true" EnableComments="true" Publish="true">
          <pnp:Sections>
            <pnp:Section>
              <pnp:Controls>
                <pnp:CanvasControl WebPartType="Custom" ControlId="34f46dbd-abbb-4ff9-be98-7483df537309" Order="1" Column="1">
                  <pnp:CanvasControlProperties>
                    <pnp:CanvasControlProperty Key="PropName" Value="PropValue" />
                  </pnp:CanvasControlProperties>
                </pnp:CanvasControl>
              </pnp:Controls>
            </pnp:Section>
          </pnp:Sections>
        </pnp:ClientSidePage>
      </pnp:ClientSidePages>
    </pnp:ProvisioningTemplate>
  </pnp:Templates>
</pnp:Provisioning>
</code></pre>

<p>This XML sample shows configuration of creation <code>SamplePage01.aspx</code> page with one sections and a custom web part placed to the first and the only column in this case.</p>

<p>Having such a template it can be applyed to a site with a bit of PowerShell:</p>

<pre><code class="language-powershell">$Connection = Connect-PnPOnline -Url $SiteUrl -UseWebLogin -ReturnConnection;
Apply-PnPProvisioningTemplate -Path $SchemaPath -Connection $Connection;
</code></pre>

<p>Where:</p>

<ul>
<li><code>$SiteUrl</code> is a URL of SharePoint modern site, </li>
<li><code>$SchemaPath</code> is path to the XML template.</li>
</ul>

<p>Declarative style gives an idea how to organize pages, sections and web parts. Let's investigate canvas control in particular.</p>

<pre><code class="language-xml"><!-- Out of the box web part -->
<pnp:CanvasControl
  WebPartType="Spacer"
  JsonControlData="{&quot;autoHide&quot;:true,&quot;height&quot;:56}"
  Order="1" Column="1"
/>

<!-- Custom web part -->
<pnp:CanvasControl
  WebPartType="Custom"
  ControlId="4f87b698-f910-451f-b4ea-7848a472af0f"
  JsonControlData="{&quot;description&quot;:&quot;Seattle&quot;,&quot;timeZoneOffset&quot;:10}"
  Order="1" Column="2"
/>
</code></pre>

<p>The example above shows OOTB web part provisioning definition. For OOTB controls PnP schema has <code>WebPartType</code>s dictionary, no need in providing <code>ControlId</code>s. For a custom types, ControlId is required. It can be easily found in maintanence mode or web part manifest.</p>

<p>The most annoying part is providing properties, i.e., <code>JsonControlData</code> stored escaped version of properties JSON. Yet you can get used dealing with this rather soon, especially, for some simple cases the props can be provided in XML way:</p>

<pre><code class="language-xml"><pnp:CanvasControlProperties>
  <pnp:CanvasControlProperty Key="PropName" Value="PropValue" />
</pnp:CanvasControlProperties>
</code></pre>

<p>A good example of web parts provisioning and modern SharePoint solution in general with all moving parts can be found in <a href="https://github.com/SharePoint/sp-starter-kit">SharePoint Starter Kit</a> repository.</p>

<h3 id="pnpjsprovisioning">PnPjs provisioning</h3>

<p><a href="https://github.com/pnp/pnpjs">PnPjs</a>, client side libraries for Microsoft 365, wrapper for SharePoint REST API and much more, also <a href="https://pnp.github.io/pnpjs/sp/client-side-pages.html">provides its mechanisms</a> for dealing with client side pages via REST API.</p>

<p>With REST API, most of the actions with client site pages and modern web parts are in out disposal.</p>

<pre><code class="language-javascript">import { sp, ClientSidePage, ClientSideWebpart, ClientSideText } from '@pnp/sp';

(async () => {

  const page = await sp.web.addClientSidePage('SamplePage01.aspx', 'Sample Page 01');

  // Getting existing page
  // const pageFile = sp.web.getFileByServerRelativeUrl(`${webUri}/SitePages/SamplePage01.aspx`);
  // const page = await ClientSidePage.fromFile(pageFile);

  page.sections = [];
  const section = page.addSection();

  // Placing all the webparts in one section

  // Standard text control
  section.addControl(new ClientSideText('HTML content goes here'));

  // Custom 3rd party webpart
  section.addControl(
    new ClientSideWebpart('Custom web part', null, {
      parameter01: 'value 01'
    }, '34f46dbd-abbb-4ff9-be98-7483df537309')
  );

  // Image gallery webpart
  section.addControl(
    new ClientSideWebpart('ImageGallery', null, {
      layout: 2,
      gridSettings: {
        imageSize: 2,
        imageCropping: 1,
        imageAspectRatio: 1,
        lightbox: false
      },
      images: [
        { url: '/sites/hub/SiteAssets/ImageGallery/88876.jpg' },
        { url: '/sites/hub/SiteAssets/ImageGallery/77559.jpg' },
        { url: '/sites/hub/SiteAssets/ImageGallery/77371.jpg' },
        { url: '/sites/hub/SiteAssets/ImageGallery/36732.jpg' },
        { url: '/sites/hub/SiteAssets/ImageGallery/97899.jpg' }
      ]
    }, 'af8be689-990e-492a-81f7-ba3e4cd3ed9c')
  );

  await page.save();

})()
  .then(_ => console.log('Done'))
  .catch(console.log);
</code></pre>

<p>Such scripts can be a part of admin applications within SPFx solution for example, can be executed right in the browser using <a href="https://chrome.google.com/webstore/detail/sp-editor/ecblfcmjnbbgaojblcpmjoamegpbodhd?hl=en">SP Editor</a> extension, or can run in Node.js process.</p>

<h2 id="wrappingup">Wrapping up</h2>

<p>Both PnP Provisioning (.Net, PowerShell) and PnPjs scripts are friendly for automated processes and CI/CD. In my opinion these tools are mandatory and de-facto for modern SharePoint developers and administrators.</p>

<p>The second wrapping idea is that it has been never so easy to provision pages and web parts as it is now with Modern cutting edge SharePoint.</p></body></html>]]></content:encoded></item><item><title><![CDATA[Contribution to PnP JS Core: Debugging source code changes]]></title><description><![CDATA[<html><head></head><body><p>While contributing to the Open Source project one should follow blueprints of the community project at the same time integrate his development workflow effectively. <br>
This post is about the way I use to debug library when contributing to PnP JS Core. The same techniques can be applied to any TypeScript</p></body></html>]]></description><link>/2017/12/02/contribution-to-pnp-js-core-debugging-source-changes/</link><guid isPermaLink="false">fba1140f-a558-45b4-849d-3344c70ec93a</guid><category><![CDATA[PnP JS Core]]></category><category><![CDATA[Toolchain]]></category><category><![CDATA[development]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[sp-pnp-node]]></category><category><![CDATA[Debug]]></category><category><![CDATA[TypeScript]]></category><category><![CDATA[VS Code]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Sat, 02 Dec 2017 11:07:02 GMT</pubDate><media:content url="/content/images/2017/12/vscode_debug_02.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2017/12/vscode_debug_02.png" alt="Contribution to PnP JS Core: Debugging source code changes"><p>While contributing to the Open Source project one should follow blueprints of the community project at the same time integrate his development workflow effectively. <br>
This post is about the way I use to debug library when contributing to PnP JS Core. The same techniques can be applied to any TypeScript project. But as the SharePoint development has its nuances setup is unique in some parts. <br>
I really hope to inspire you to contribute to Open Source too.</p>

<h2 id="pnpjscoredebug">PnP JS Core Debug</h2>

<p><a href="https://github.com/koltyakov/PnP-JS-Core-Debug">PnP JS Core Debug</a> is a helper project which allows debugging local sources of PnP JS Core right in TypeScript with live requests to SharePoint environment in Node.js.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>These libraries are required for developing PnP JS Core and should be installed globally:</p>

<ul>
<li>Node.js</li>
<li>TypeScript</li>
<li>TSLint</li>
<li>Gulp</li>
</ul>

<pre><code class="language-bash">npm install typescript tslint ts-node gulp -g  
</code></pre>

<h2 id="forkprojects">Fork projects</h2>

<p>Before go changing sources these project should be forked.</p>

<ul>
<li><a href="https://github.com/SharePoint/PnP-JS-Core">PnP JS Core</a></li>
<li><a href="https://github.com/koltyakov/PnP-JS-Core-Debug">PnP JS Core Debug</a></li>
</ul>

<p>First one is the repo with sp-pnp-js itself, the second is a separate project, which helps to separate library unrelated code and, at the same time, keep track of these changes as they can be important for a contributor. </p>

<h2 id="clonetheforks">Clone the forks</h2>

<p>Projects' folders should be located in the same root folder.</p>

<pre><code class="language-bash">git clone https://github.com/[namespace]/PnP-JS-Core  
git clone https://github.com/[namespace]/PnP-JS-Core-Debug  
</code></pre>

<p><code>[namespace]</code> stands for you or your company GitHub account.</p>

<p>Separation of the sources makes your commits cleaner automatically, as you only change the actual part of the library. <br>
Debug project is linked with source project in such a way, that no ahead of time transpilation is needed, no <code>npm link</code> is needed. Once added or changed the method in the library is immediately effected in debug project (even with IntelliSense). Here is the power of TypeScript.</p>

<h2 id="installdependencies">Install dependencies</h2>

<p>Dependencies should be restored in both projects' folders:</p>

<pre><code class="language-bash">npm install  
</code></pre>

<p>or</p>

<pre><code class="language-bash">yarn install  
</code></pre>

<p>I personally still prefer yarn over npm (even v.5). It still faster and works perfectly for me.</p>

<h2 id="vscodeisoureditorofchoise">VS Code is our editor of choise</h2>

<p>Open both projects in VS Code. Workspaces are the best option here.</p>

<p><img src="/content/images/2017/12/vscode_workspace.png" alt="Contribution to PnP JS Core: Debugging source code changes"></p>

<p>This new workspace feature allows opening multiple folder-projects in one instance of VS Code. It's especially handy in our case of applying changes in the lib's project and another one to running debug stuff. </p>

<h2 id="upstreamforpnpjscore">Upstream for PnP JS Core</h2>

<p>Add upstream for PnP JS Core (a one-time operation). <br>
In <code>PnP JS Core</code>'s folder:</p>

<pre><code class="language-bash">git remote add upstream https://github.com/SharePoint/PnP-JS-Core  
</code></pre>

<p>This will allow syncing your repository sources with main repo with:</p>

<pre><code class="language-bash">git fetch upstream dev  
</code></pre>

<h2 id="featurebranch">Feature branch</h2>

<p>It's recommended using feature branches for code changes related to a specific feature or bug fix.</p>

<p>Before creating a feature branch make sure:</p>

<ul>
<li>A feature branch is based on PnP JS Core <code>dev</code> branch.</li>
<li>The local branch is synced with remote <code>upstream</code> branch (this can be done with feature branch too).</li>
</ul>

<pre><code class="language-bash">git checkout dev  
git fetch upstream dev  
git checkout -b [name_of_your_new_branch]  
</code></pre>

<p>It's better to prefix feature branch with <code>dev-</code>.</p>

<h2 id="connectingtoolswithsharepoint">Connecting tools with SharePoint</h2>

<p>On first run SharePoint environment connection should be initiated:</p>

<h3 id="runnpmtask">Run npm task</h3>

<pre><code class="language-bash">npm run init  
</code></pre>

<p>You'll be prompted with SharePoint web URL and credentials, just follow the wizard:</p>

<p><img src="/content/images/2017/12/auth_init.png" alt="Contribution to PnP JS Core: Debugging source code changes"></p>

<p>Read <a href="https://github.com/s-KaiNet/node-sp-auth">more</a> about supported auth scenarios.</p>

<h3 id="configurationfiles">Configuration files</h3>

<p>Connection is saved to config files which are better to exclude from a git repository. <br>
By default config path is <code>./config/private.json</code>. Passwords in configs are stored in an encrypted way.</p>

<p>Config sample:</p>

<pre><code class="language-json">{
  "siteUrl": "https://contoso.sharepoint.com/sites/dev-a",
  "strategy": "UserCredentials",
  "username": "andrew.koltyakov@contoso.onmicrosoft.com",
  "password": "bcccd4e6025...ZH+ZY5X2A=="
}
</code></pre>

<h2 id="makingchanges">Making changes</h2>

<p>Now you can apply changes to PnP JS Core project sources (your local copy). <br>
Follow <a href="https://github.com/SharePoint/PnP-JS-Core/wiki/Getting-Started:-Contribute">Getting Started: Contribute</a> wiki page's instructions.</p>

<h2 id="debuggingwithpnpjscoredebug">Debugging with PnP JS Core Debug</h2>

<p>In <code>PnP-JS-Core-Debug/runners</code> project's folder create a <code>.ts</code> file.</p>

<p>Wrap file with:</p>

<pre><code class="language-TypeScript">import { Web } from './../../PnP-JS-Core/src/pnp';  
import { initEnvironment as init } from './../utils/pnpnode';  
import './../utils/setup';

init().then(async settings => {

  let web = new Web(settings.siteUrl);
  // executing methods to test

}).catch(console.log);
</code></pre>

<p>Place debug break points in PnP JS Core <code>.ts</code> sources or your custom code. <br>
Open a runner which executes logic to test and start a debugger for the current file.</p>

<p><img src="/content/images/2017/12/vscode_debug_01.png" alt="Contribution to PnP JS Core: Debugging source code changes"></p>

<p>Now all the power of VS Code debugger is our oyster!</p>

<p><img src="/content/images/2017/12/vscode_debug_02.png" alt="Contribution to PnP JS Core: Debugging source code changes"></p>

<p>As usual, feel free ask questions in <a href="https://gitter.im/OfficeDev/PnP-JS-Core">Gitter</a> chat.</p></body></html>]]></content:encoded></item><item><title><![CDATA[Local SPFx Workbench against real SharePoint API]]></title><description><![CDATA[<html><head></head><body><p>When dealing with SharePoint Framework (SPFx), a developer can choose local or remote runtime debug strategy.</p>

<p>By default by running <code>gulp serve</code>, the local workbench is started. Local workbench opens on <code>https://localhost:4321/temp/workbench.html</code>, it is a page which mimics SharePoint modern UI, yet it's just a</p></body></html>]]></description><link>/2017/11/27/spfx-workbench-against-real-sharepoint-api/</link><guid isPermaLink="false">20b0f4d0-75de-43d2-b7c5-79034d42f90b</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[development]]></category><category><![CDATA[sp-rest-proxy]]></category><category><![CDATA[Toolchain]]></category><category><![CDATA[Framework]]></category><category><![CDATA[SPFx]]></category><category><![CDATA[sp-pnp-js]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Mon, 27 Nov 2017 18:21:03 GMT</pubDate><media:content url="/content/images/2017/11/spfx-proxy-wide.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2017/11/spfx-proxy-wide.png" alt="Local SPFx Workbench against real SharePoint API"><p>When dealing with SharePoint Framework (SPFx), a developer can choose local or remote runtime debug strategy.</p>

<p>By default by running <code>gulp serve</code>, the local workbench is started. Local workbench opens on <code>https://localhost:4321/temp/workbench.html</code>, it is a page which mimics SharePoint modern UI, yet it's just a locally served page, it has no connection to SharePoint APIs.</p>

<p>Local mode provided the capability of mocking UI and styling based on some artificial data prepared beforehand or generated with specific libs. Local workbench uses hot module reload on changes, once started you just change the code and check for updates in browser's window.</p>

<p>Sometimes, real API's response data is required and mocking is too time-consuming and unproductive. SPFx has a solution for this. There is online version of the workbench, which can be found via <code>[SHAREPOINT_WEB_URL]/_layouts/15/workbench.aspx</code>. When <code>gulp serve --nobrowser</code> (<code>--nobrowser</code> key is handy when you get tired of auto-opening local workbench page) has been started web parts can be placed to online workbench while scripts can be hosted from a local machine.</p>

<p>Such mode allows acting with real data and REST API (or other APIs).</p>

<p>At this moment you might ask "Ok, online workbench saves the day, what the deal? Why do I need local workbench ever talking to the APIs?". Actually, it's a good question, but believe me, there are use cases (for example using web parts in production and developing and delivering new versions within one single tenant). Would be cool hearing about your use cases in the comment section below!</p>

<p>Anyway, it's super simple to configure "local" to work with "remote", let's take a look how.</p>

<h2 id="configuringspfxsolutiontoworkwiththeproxy">Configuring SPFx solution to work with the proxy</h2>

<p>As a prerequisite SPFx project should be created.</p>

<p>1. Install SharePoint REST Proxy in SPFx solution's project.</p>

<pre><code class="language-bash">npm install sp-rest-proxy --save-dev  
</code></pre>

<p><a href="https://github.com/koltyakov/sp-rest-proxy">sp-rest-proxy</a> is a dev dependency, it provides authorized anonymous proxy gateway to SharePoint APIs with CORS enabled. So any page on a developer's machine can request SharePoint API seamlessly.</p>

<p>2. Create <code>proxy.js</code> file in a root or wherever in the project with the following content:</p>

<pre><code class="language-javascript">const CertificateStore = require('@microsoft/gulp-core-build-serve/lib/CertificateStore');  
const RestProxy = require('sp-rest-proxy');

const settings = {  
  port: 4323,
  protocol: 'https',
  ssl: {
    cert: CertificateStore.default.instance.certificateData,
    key: CertificateStore.default.instance.keyData
  }
};

const restProxy = new RestProxy(settings);  
restProxy.serve();  
</code></pre>

<p>[ <a href="https://github.com/koltyakov/sp-rest-proxy/blob/master/examples/spfx-proxy-example/proxy.js">Download script</a> ]</p>

<p>To make requests from the local workbench to proxy happen, the proxy's local server should be running on https/SSL. Here is the script we're using some sort of trick and reusing SPFx certificate, so proxy's SSL trust is tied up with workbench's cert. (You can trust/untrust SPFx cert with <code>gulp trust-dev-cert</code> and <code>gulp untrust-dev-cert</code> accordingly).</p>

<p>3. Create npm task to start proxy, e.g. <code>"proxy": "node ./proxy"</code>.</p>

<p>4. Run and configure proxy's connection to the environment by <code>node ./proxy</code> or currently created npm task <code>npm run proxy</code>.</p>

<p>This is required once you need to "bind" the proxy with remote SharePoint server and provide credentials. Follow the wizard prompts to finish this step. Check out project's <a href="https://github.com/koltyakov/sp-rest-proxy">page</a> for more details.</p>

<p>5. Configure a task to start proxy and gulp serve at the same time, e.g. using <a href="https://www.npmjs.com/package/concurrently">concurrently</a> or <a href="https://www.npmjs.com/package/npm-run-all">npm-run-all</a>.</p>

<p>Setup with <code>concurrently</code>:</p>

<p>5.1 Install dependency:</p>

<pre><code class="language-bash">npm install concurrently --save-dev  
</code></pre>

<p>5.2 Add npm task to package.json:</p>

<pre><code class="language-json">"scripts": {
  ...
  "serve": "concurrently --kill-others \"npm run proxy\" \"gulp serve\""
  ...
}
</code></pre>

<p>Now you can start both proxy and SPFx local server with one command:</p>

<pre><code class="language-bash">npm run serve  
</code></pre>

<p>We are done with configuration. Now it's time to cover some coding aspects.</p>

<h2 id="detectinglocalmode">Detecting local mode</h2>

<p>With proxy at our disposal, SPFx consumes real API in local mode. All we need to do is implement variability of switching between endpoints.</p>

<p>Let's assume your SharePoint Web is located at <code>https://contoso.sharepoint.com/sites/site/my_web</code>.</p>

<p>SPFx web part is generally agnostic to the future location of the web. Web URL can be get known in a runtime using <code>this.context.pageContext.web</code>'s object properties: <code>absoluteUrl</code> or <code>serverRelativeUrl</code>. REST requests are usually built using this variables.</p>

<p>The local mode, in the opposite, knows nothing about target environment. You're in charge of pointing HttpClient to request correct URLs. One of them is kind of static, it's a proxy's host URL, <code>https://localhost:4323</code>, web relative URL should be somewhere in the settings.</p>

<p>In the local mode, a web part should construct the following sort of endpoint for requests <code>https://localhost:4323/sites/site/my_web/_api/...</code>. It should always deal with absolute URLs in this kind of setup.</p>

<p>Once this is clear, the question is how to detect local mode gracefully. Luckily SPFx has helpers for this situation (and there is no need to use <code>window.location.href.indexOf('https://localhost:') === 0</code>):</p>

<pre><code class="language-typescript">import { Environment, EnvironmentType } from '@microsoft/sp-core-library';

if (Environment.type === EnvironmentType.Local) {  
  // Local mode
} else {
  // Online mode
}
</code></pre>

<p>We can rely code logic on this condition and provide initial endpoint rather robustly.</p>

<h2 id="bonussectionconfiguringpnpjscore">Bonus section - configuring PnP JS Core</h2>

<p>Oh, you might know, I'm a huge fan of <a href="https://github.com/SharePoint/PnP-JS-Core">sp-pnp-js</a> and prefer this library over building requests manually.</p>

<p>PnP JS Core works nicely with SPFx and I glad to inform you it works great with SPFx plus SharePoint REST Proxy. Once configured properly.</p>

<pre><code class="language-typescript">import { Web, setup } from 'sp-pnp-js';  
import { proxyUrl, webRelativeUrl } from './../settings';  
// settings.ts should be created with corresponding exports

...
let web: Web;  
if (Environment.type === EnvironmentType.Local) {  
  web = new Web(`${proxyUrl}${webRelativeUrl}`);
} else {
  // On SharePoint page sp-pnp-js should be configured with
  setup({ spfxContext: this.context });
  // or a Web object should be created with explicit web URL
  web = new Web(this.context.pageContext.web.absoluteUrl);
}
// Then universal pnp code and dealing with SPFx specifics
/*
web.lists.get()  
  .then(...).catch(...);
*/
...
</code></pre>

<h2 id="example">Example</h2>

<p>I've published a simple example with the setup described above. The example can be found <a href="https://github.com/koltyakov/sp-rest-proxy/tree/master/examples/spfx-proxy-example">here</a>. <br>
<img src="/content/images/2017/11/demo.jpg" alt="Local SPFx Workbench against real SharePoint API"></p></body></html>]]></content:encoded></item><item><title><![CDATA[SharePoint .Net authentication via embedded Node.js]]></title><description><![CDATA[<html><head></head><body><h2 id="intro">Intro</h2>

<p>I'm a fan of crazy experiments with technologies and code. How many times I catch myself on saying "Why don't to [insane idea to implement]", then in one grasp after a while seating and scratching my head with "Oh shoot! It's working! O_o". That's how some of my</p></body></html>]]></description><link>/2017/10/30/sharepoint-net-authentication-via-embedded-node-js/</link><guid isPermaLink="false">599df659-c3c2-470b-8477-da4098979eb5</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[API]]></category><category><![CDATA[development]]></category><category><![CDATA[.Net]]></category><category><![CDATA[Authentication]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Sun, 29 Oct 2017 23:05:08 GMT</pubDate><media:content url="/content/images/2017/10/PimpMyDonNetWithNode-2.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><h2 id="intro">Intro</h2>

<img src="/content/images/2017/10/PimpMyDonNetWithNode-2.png" alt="SharePoint .Net authentication via embedded Node.js"><p>I'm a fan of crazy experiments with technologies and code. How many times I catch myself on saying "Why don't to [insane idea to implement]", then in one grasp after a while seating and scratching my head with "Oh shoot! It's working! O_o". That's how some of my open source projects saw the light.</p>

<p>Last week there was the idea to dig <a href="https://github.com/tjanczuk/edge">Edge.js</a> a bit. Edge.js is a library which allows running CLR languages like C# .Net from Node.js and vice versa.</p>

<p>For a while, we had a plan of syncing <code>sp-cmd-deploy</code> (.Net module for getting CSOM context) with <code>node-sp-auth-config</code> (Node.js module for a work with auth). Both modules have some common ideas. And it would have been great to share some settings between them.</p>

<p>Jungling these ideas somebody said "Why don't we just use <code>node-sp-auth-conf</code> in our .Net apps too?". <br>
Well... said and done!</p>

<h2 id="spauthnhttpsgithubcomkoltyakovspauthn"><a href="https://github.com/koltyakov/SPAuthN">SPAuthN</a></h2>

<p>Here our pet Frankenstein <code>SPAuthN</code>. <br>
SPAuthN is a .Net library available in NuGets. And it's a wrapper for <a href="https://www.npmjs.com/package/node-sp-auth">node-sp-auth</a> and <a href="https://www.npmjs.com/package/node-sp-auth-config">node-sp-auth-config</a>. <br>
This monster allows authenticating in SharePoint in whatever you need scenarios and provides a wizard-like approach for building and managing connection config files.</p>

<h2 id="disclaimer">Disclaimer</h2>

<p>Before reading further, attention, please! On the first place, it is a crazy experiment which solves one of our very specific tasks for a frontier technology stack with SharePoint, Node.js and .Net where we need running the same exactly auth mechanisms which we use in Node.js but in .Net applications. We know exactly what we're doing and why. Please use the lib only in the case when native .Net credentials strategies do not suite your app.</p>

<h2 id="forwhomisthislibrary">For whom is this library?</h2>

<p>For folks who used to create applications for SharePoint with authentication level powered by node-sp-auth-config and node-sp-auth-config and who desire reuse authentication settings parameters and formats in .Net application.</p>

<p>For geeks from geeks passionated with funky technology experiments on their way doing awesome stuff.</p>

<p>For the cases when one tool should rule *all possible authentication strategies in SharePoint.</p>

<p>And definitely not for the situations when these work for you:</p>

<ul>
<li>context.Credentials = new SharePointOnlineCredentials("username", "securepass");</li>
<li>context.Credentials = new NetworkCredential("username", "password", "domain");</li>
<li>Any other native authentication routes.</li>
</ul>

<h2 id="features">Features</h2>

<p>SPAuthN supports authenticating against SharePoint Online, 2016, 2013. <br>
It's one ring to rule Addin only permissions, SAML based with user credentials, ADFS user credentials, User credentials through the http NTLM handshake, ADFS user credentials, Form-based (FBA), Forefront TMG authentication strategies.</p>

<h2 id="howitworksinanutshell">How it works in a nutshell</h2>

<ul>
<li>Edge.js's Func wraps some Node.js scripts with wizard, authentication, and utilities</li>
<li>Edge.js provides embedded runtime for server-side JavaScript</li>
<li>Script utilities check and install node module dependencies with <code>node-sp-auth</code> and others</li>
<li>Execution is passed to JS side when done option results are passed back to managed code</li>
<li>Result object contains auth headers which can be injected to HTTP requests and viola!</li>
</ul>

<h2 id="howtouse">How to use</h2>

<pre><code class="language-csharp">Options options = SPAuth.GetAuth();  
</code></pre>

<p>That's it! Really!</p>

<p>Now <code>options.headers</code> object contains Cookie or Authorization which can be injected to web requests. <br>
This is a low level, session timeouts should be controlled manually.</p>

<h2 id="firstrun">First run</h2>

<p>During very first execution, node modules dependencies are installed. This can take a couple of seconds, second run doesn't need this process repetition so is much faster.</p>

<h2 id="credentials">Credentials</h2>

<p><a href="https://github.com/koltyakov/node-sp-auth-config">node-sp-auth-config</a> is responsible for prompting auth strategy and credentials:</p>

<p><img src="/content/images/2017/10/auth-wizard.gif" alt="SharePoint .Net authentication via embedded Node.js"></p>

<p>By default, after the prompts are done <code>./config/private.json</code> file is created in the root folder of the app.</p>

<p><img src="/content/images/2017/10/private-json.png" alt="SharePoint .Net authentication via embedded Node.js"></p>

<p><code>GetAuth</code> checks for <code>./config/private.json</code> and continues without prompts if all needed for the strategy parameters are filled in.
The password is stored as a secure string, it can be used only on the machine where it was generated. The password can be rewritten in the config and it will be encrypted on next auth method run.</p>

<h2 id="arguments">Arguments</h2>

<p><code>GetAuth</code> method receives a string with arguments which are passed as initiators to <a href="https://github.com/koltyakov/node-sp-auth-config/blob/master/src/interfaces/index.ts#L35">AuthConfigSettings</a>.</p>

<pre><code class="language-csharp">Options options = SPAuth.GetAuth("--encryptPassword=false --configPath='./config/private.uat.json'");  
</code></pre>

<h3 id="argumentsusecases">Arguments use cases</h3>

<h4 id="redefineprivateconfigfilepath">Redefine private config file path</h4>

<pre><code class="language-bash">--configPath='./config/private.prod.json'
</code></pre>

<h4 id="disablepasswordencryption">Disable password encryption</h4>

<pre><code class="language-bash">--encryptPassword=false
</code></pre>

<h4 id="disablesavingprivateconfigondisc">Disable saving private config on disc</h4>

<pre><code class="language-bash">--saveConfigOnDisk=false
</code></pre>

<h4 id="enforceparametersprompts">Enforce parameters prompts</h4>

<pre><code class="language-bash">--forcePrompts=true
</code></pre>

<h4 id="rawauthoptionsexample">Raw auth options (example)</h4>

<pre><code class="language-bash">--authOptions.siteUrl="http://sharepoint" --authOptions.username="user@contoso.com" --authOptions.password="p@ssw0rd" --saveConfigOnDisk=false
</code></pre>

<h3 id="usageexamples">Usage examples</h3>

<h4 id="webrequest">WebRequest</h4>

<pre><code class="language-csharp">Options options = SPAuth.GetAuth("--configPath='./config/private.json'");  
WebRequest request = WebRequest.Create(options.SiteUrl + "/_api/web?$select=Title");  
request.Headers = options.Headers;  
HttpWebResponse response = (HttpWebResponse)request.GetResponse();  
if (response.StatusCode == HttpStatusCode.OK || response.StatusCode == HttpStatusCode.NoContent)  
{
  Stream dataStream = response.GetResponseStream();
  XDocument xDoc = XDocument.Load(dataStream);

  XNamespace ns = "http://www.w3.org/2005/Atom";
  XNamespace d = "http://schemas.microsoft.com/ado/2007/08/dataservices";
  XNamespace m = "http://schemas.microsoft.com/ado/2007/08/dataservices/metadata";

  string title = xDoc
    .Element(ns + "entry").Element(ns + "content")
    .Element(m + "properties").Element(d + "Title").Value;

  Console.WriteLine("REST | Web title is: {0}", title);
  dataStream.Close();
}
response.Close();  
</code></pre>

<h4 id="csom">CSOM</h4>

<pre><code class="language-csharp">Options options = SPAuth.GetAuth("--configPath='./config/private.json'");  
using (ClientContext clientContext = new ClientContext(options.SiteUrl))  
{
  clientContext.ExecutingWebRequest += (sender, arguments) =>
  {
    foreach (var key in options.Headers.AllKeys)
    {
      arguments.WebRequestExecutor.RequestHeaders[key] = options.Headers[key];
    }
  };

  var web = clientContext.Web;
  clientContext.Load(web);
  clientContext.ExecuteQuery();

  Console.WriteLine("CSOM | Web title is: {0}", web.Title);
}
</code></pre>

<h2 id="afterwords">Afterwords</h2>

<p>Please don't understand me wrong. I know that it's a crazy stuff, but at the same time, it's an interesting example of reusing code base from absolutely different worlds and stacks and integrating one thing into another.</p></body></html>]]></content:encoded></item><item><title><![CDATA[Getting started with React local development for SharePoint with sp-rest-proxy]]></title><description><![CDATA[<html><head></head><body><h2 id="intro">Intro</h2>

<p>React is a beloved library of many folks which allows building modular reusable user interfaces and applications. <br>
As a most of modern tools React has a nice ecosystem of toolchains for scaffolding, development and build processes. But when it comes to creating React app for SharePoint reusing common (native)</p></body></html>]]></description><link>/2017/10/29/getting-started-with-react-local-development-for-sharepoint-with-sp-rest-proxy/</link><guid isPermaLink="false">11335bc7-4917-4a54-be89-0b5b8eb15827</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[sp-rest-proxy]]></category><category><![CDATA[Toolchain]]></category><category><![CDATA[REST]]></category><category><![CDATA[API]]></category><category><![CDATA[development]]></category><category><![CDATA[React]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Sun, 29 Oct 2017 15:57:24 GMT</pubDate><media:content url="/content/images/2017/10/ReactPlusProxy1.jpg" medium="image"/><content:encoded><![CDATA[<html><head></head><body><h2 id="intro">Intro</h2>

<img src="/content/images/2017/10/ReactPlusProxy1.jpg" alt="Getting started with React local development for SharePoint with sp-rest-proxy"><p>React is a beloved library of many folks which allows building modular reusable user interfaces and applications. <br>
As a most of modern tools React has a nice ecosystem of toolchains for scaffolding, development and build processes. But when it comes to creating React app for SharePoint reusing common (native) toolchains one can scratch his/her head for a while until become productive.</p>

<p>Luckily, there is a simple solution which is applicable for all recent SharePoint versions (SharePoint Online, 2016, 2013). <br>
This article is a quick guide how to configure local development of React apps against real SharePoint data and APIs.</p>

<p>Fasten your seatbelt, let's start...</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>We're going to use <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a> it's quite popular and neat generator for React. The generator should be installed globally. <br>
Of course, as we deal with front-end development, Node.js and NPM should be installed too. <br>
Some details about setting up dev machine are <a href="http://blog.arvosys.com/2016/08/25/preparing-development-machine-for-client-side-sharepoint-projects-mac-and-pc/">here</a>, but most of those who are asking "how to develop React app for SharePoint" might already know all of these, so just skipping some obvious steps here.</p>

<h2 id="guide">Guide</h2>

<p>1. Create React app && navigate to it:</p>

<pre><code class="language-bash">create-react-app sharepoint-react-webpart && cd sharepoint-react-webpart  
</code></pre>

<p>2. Install <code>sp-rest-proxy</code> and <code>concurrently</code> dependency:</p>

<ul>
<li><a href="https://github.com/koltyakov/sp-rest-proxy">sp-rest-proxy</a> - is the lib which takes care of proxying requests to SharePoint APIs. Read more about <a href="http://blog.arvosys.com/2016/09/03/sharepoint-rest-api-proxy-for-local-serve-in-node-js/">proxy</a>.</li>
<li><code>concurrently</code> - helps running multiple <code>npm</code> tasks in one command and terminal window </li>
</ul>

<pre><code class="language-bash">npm install sp-rest-proxy concurrently --save-dev  
</code></pre>

<p>or using yarn:</p>

<pre><code class="language-bash">yarn add sp-rest-proxy concurrently --dev  
</code></pre>

<p>3. Add scripts to <code>package.json</code>:</p>

<pre><code class="language-json">{
  "scripts": {
    ...
    "proxy": "node ./api-server.js",
    "startServers": "concurrently --kill-others \"npm run proxy\" \"npm run start\""
    ...
  }
}
</code></pre>

<p>Script names can be as one wish. <code>npm run start</code> stands for react app serve. <br>
<code>node ./api-server.js</code> starts <code>sp-rest-proxy</code> server.</p>

<p>4. Add API proxy setting into <code>package.json</code>:</p>

<pre><code class="language-json">{
  "proxy": "http://localhost:8081"
}
</code></pre>

<p>This is the address which corresponds to <code>sp-rest-proxy</code> startup settings. <br>
Proxy setting is a Webpack serve feature which transfers localhost request to the sp-rest-proxy. </p>

<p>Package.json should looks like this:</p>

<p><img src="/content/images/2017/10/react-sp-package.jpg" alt="Getting started with React local development for SharePoint with sp-rest-proxy"></p>

<p>5. Create proxy server script, e.g. <code>./api-server.js</code>:</p>

<pre><code class="language-javascript">const RestProxy = require('sp-rest-proxy');

const settings = {  
  port: 8081
};

const restProxy = new RestProxy(settings);  
restProxy.serve();  
</code></pre>

<p>There are more settings, yet this is the simplest configuration with just a port definition.</p>

<p>6. Configure <code>sp-rest-proxy</code>:</p>

<p>6.1. Run:</p>

<pre><code class="language-bash">npm run proxy  
</code></pre>

<p>6.2. and provide SharePoint connection options.</p>

<p>Connection parameters will be prompted and chances for a mistake are minimal.</p>

<p>By default, <code>./config/private.json</code> is created. This files stores connection settings and credentials. <br>
It's good to add <code>config/private.json</code> to <code>.gitignore</code> to avoid unnecessary saving of the private options to a git repository.</p>

<p>6.3. Check if credentials are correct by navigating to <code>http://localhost:8081</code> and executing any REST request, e.g. <code>/_api/web</code>. On success, some data should be responded from SharePoint API.</p>

<p>Stop <code>sp-rest-proxy</code>, Ctrl+C in a console.</p>

<p>7. Start local development serve:</p>

<pre><code class="language-bash">npm run startServers  
</code></pre>

<p>Now when both servers have been started your React app can request for SharePoint API as if it were already deployed to SharePoint page, WebPack proxies local API requests to <code>sp-rest-proxy</code> and then requests to real SharePoint instance.</p>

<p>E.g., if open <code>http://localhost:3000</code> in a browser and run:</p>

<pre><code class="language-javascript">fetch(`/_api/web`, {  
    accept: 'application/json;odata=verbose',
})
  .then(r => r.json())
  .then(console.log)
  .catch(console.log);
</code></pre>

<p>Data from SharePoint is here on the page! Black magic! <br>
Now you can create something awesome being productive within the stack. Happy codding!</p></body></html>]]></content:encoded></item><item><title><![CDATA[SharePoint front-end projects automation and tasks tool-belt]]></title><description><![CDATA[<html><head></head><body><p>I was highly requested to document <a href="https://github.com/koltyakov/generator-sppp">SharePoint Push & Pull</a> generator projects' build and configuration process and parameters recently. Despite the fact that the project is open sourced there was real lack of documentation and a lot of things were only in my head.</p>

<p>The generator is the way to combine</p></body></html>]]></description><link>/2017/10/04/sharepoint-front-end-projects-automation-and-tasks-tool-belt/</link><guid isPermaLink="false">cfd149df-d289-4179-be0f-fa768d8b3530</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Yeoman]]></category><category><![CDATA[Front-End]]></category><category><![CDATA[Build]]></category><category><![CDATA[Tasks]]></category><category><![CDATA[Automation]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Wed, 04 Oct 2017 15:53:34 GMT</pubDate><media:content url="/content/images/2017/10/sp-build-tasks.jpg" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2017/10/sp-build-tasks.jpg" alt="SharePoint front-end projects automation and tasks tool-belt"><p>I was highly requested to document <a href="https://github.com/koltyakov/generator-sppp">SharePoint Push & Pull</a> generator projects' build and configuration process and parameters recently. Despite the fact that the project is open sourced there was real lack of documentation and a lot of things were only in my head.</p>

<p>The generator is the way to combine libraries and settings together and simplify reusability. There are plenty of different libraries and even technologies to make front-end solution build process smooth and easy.</p>

<p>Also, there is some sort of inception of automation layers. A lot of folks know about <code>generator-sppp</code>, a few really know that most of the magic is spelled by a dependency library called <a href="https://github.com/koltyakov/sp-build-tasks">sp-build-tasks</a>.</p>

<p>Here we're going to dive into the settings. The article is supposed to be long in some parts it accumulates project's <a href="https://github.com/koltyakov/sp-build-tasks/wiki">wiki</a> pages.</p>

<h2 id="spbuildtasks">sp-build-tasks</h2>

<p>The library was designed for usage with SharePoint Push-n-Pull Yeoman generator but can be used as a stand-alone package as well.</p>

<h3 id="recommendedusage">Recommended usage</h3>

<h4 id="checkprerequisites">Check prerequisites</h4>

<ul>
<li>Node.js</li>
<li>NPM or Yarn</li>
<li>Yeoman</li>
<li>SPPP Yeoman generator</li>
<li>TypeScript</li>
</ul>

<pre><code class="language-bash">npm install yarn yo generator-sppp typescript ts-lint -g  
</code></pre>

<h4 id="createascaffolderproject">Create a scaffolder project</h4>

<p>Run <code>yo sppp</code> in blank folder for a new project.</p>

<pre><code class="language-bash">yo sppp  
</code></pre>

<h3 id="buildoptions">Build options</h3>

<p>Build options are a layer of settings which can be defined for a project to set up its unique build workflow.</p>

<p>Settings are stored in <code>./config/app.json</code> file.</p>

<p><strong>Example setup:</strong></p>

<pre><code class="language-json">{
  "spFolder": "_catalogs/masterpage/spf",
  "distFolder": "./dist",

  "customStyles": [{
    "src": "styles/frankfurt/frankfurt.scss",
    "dist": "styles/frankfurt.min.css"
  }],

  "bundleJSLibsFiles": [
    "./node_modules/es6-promise/dist/es6-promise.auto.min.js",
    "./node_modules/whatwg-fetch/fetch.js",
    "./node_modules/sp-pnp-js/dist/pnp.js"
  ],

  "bundleCSSLibsFiles": [
    "./node_modules/datatables/media/css/jquery.dataTables.min.css"
  ],

  "copyAssetsMap": [{
    "src": [
      "./node_modules/datatables/media/images",
      "./src/images",
      "./src/scripts/modules/wysiwyg.js"
    ],
    "dist": "./dist"
  }],

  "webpackItemsMap": [{
    "entry": "./src/scripts/module-a.ts",
    "target": "module-a.js",
    "webpackConfig": {
      "cache": true,
      "devtool": "source-map",
      "plugins": []
    }
  }],
  "webpackConfig": {
    "cache": true,
    "devtool": "source-map",
    "plugins": []
  },

  "masterpagePath": "masterpage/frankfurt.master",
  "logoPath": "images/logo.png",
  "masterpageCodeName": "frankfurt",
  "platformVersion": "2016",
  "masterpage": {
    "copyright": {
      "year": "2017",
      "title": "Contoso intranet"
    }
  }
}
</code></pre>

<h4 id="buildoptionsmappingwithsharepoint">Build options: Mapping with SharePoint</h4>

<p>Build tools map local <code>dist</code> folder with remote target folder in SharePoint within site assets document library. <br>
<code>_catalogs/masterpage/some_folder</code> is recommended.
<code>SiteAssets/some_folder</code> or <code>Style Library/some_folder</code> or others can be used as well.</p>

<p>SharePoint mapping paths are configured in <code>./config/app.json</code> within the following parameters:</p>

<pre><code class="language-javascript">{
  ...
  "spFolder": "_catalogs/masterpage/spf",
    // Publishing SPWeb relative folder path in SharePoint
    // where files should be uploaded to
  "distFolder": "./dist",
    // Local distribution folder with built assets
    // ready for publishing
  ...
}
</code></pre>

<h4 id="buildoptionswebpack">Build options: Webpack</h4>

<p><code>sp-build-tasks</code> uses Webpack for packing scripts.</p>

<p>TypeScript, ES vNext or vanilla JavaScript can be used as script sources by default.</p>

<p>Webpack settings can be defined in <code>./webpack.config.js</code> in a usual for Webpack way. <br>
There is a built-in configuration and settings layer. <br>
Webpack build process can be tweaked in <code>./config/app.json</code> within the following parameters:</p>

<pre><code class="language-javascript">{
  ...
  // webpackItemsMap: Array or entry/target script pairs
  "webpackItemsMap": [{
    "entry": "./src/scripts/scriptName.ts",
      // Relative path to .ts, .js file within the project's folder structure
    "target": "scriptName.js", 
      // Relative path to output bundle script within `./dist/stripts` folder
    "webpackConfig": {} 
      // Optional Webpack configuration which is added 
      // to webpack's configs for a specific entry point 
  }],
  "webpackConfig": {},
    // Optional Webpack configuration which is added 
    // to webpack's configs for all entry points
  ...
}
</code></pre>

<h4 id="buildoptionscustomstyles">Build options: Custom styles</h4>

<p><code>sp-build-tasks</code> uses SCSS as a language for CSS sources.
SCSS files can store raw CSS as well.</p>

<p>SharePoint mapping paths are configured in <code>./config/app.json</code> within the following parameters:</p>

<pre><code class="language-javascript">{
  ...
  // customStyles: Array or a single object element src/dist pair 
  // of source style entry point and output bundle file
  "customStyles": [{
    "src": "styles/frankfurt/frankfurt.scss",
      // Source entry point path
      // relative to './src'
    "dist": "styles/frankfurt.min.css"
      // Output .css file path
      // relative to './dist'
  }],
  ...
}
</code></pre>

<h4 id="buildoptionsjslibs">Build options: JS Libs</h4>

<p>Build tools can bundle 3rd party JavaScript libraries.</p>

<p>Libraries' JavaScript paths are configured in <code>./config/app.json</code> within the following parameters:</p>

<pre><code class="language-javascript">{
  ...
  "bundleJSLibsFiles": [
    "./node_modules/es6-promise/dist/es6-promise.auto.min.js",
    "./node_modules/whatwg-fetch/fetch.js",
    "./node_modules/sp-pnp-js/dist/pnp.js"
  ],
  ...
}
</code></pre>

<p>It's recommended installing 3rd parties using <code>npm</code> or <code>bower</code> then configuring bundling within the build tools.</p>

<h4 id="buildoptionscsslibs">Build options: CSS Libs</h4>

<p>Build tools can bundle 3rd party CSS libraries.</p>

<p>Libraries' CSS paths are configured in <code>./config/app.json</code> within the following parameters:</p>

<pre><code class="language-javascript">{
  ...
  "bundleCSSLibsFiles": [
    "./node_modules/datatables/media/css/jquery.dataTables.min.css"
  ],
  ...
}
</code></pre>

<p>It's recommended installing 3rd parties using <code>npm</code> or <code>bower</code> then configuring bundling within the build tools.</p>

<h4 id="buildoptionsassetscopy">Build options: Assets copy</h4>

<p>It's better storing static assets in <code>./src</code> or other folders, which are the part of the source control system.</p>

<p>Dist folder should be mapped with SharePoint asset folder. Also, the dist folder sometime should not be a part of sources and isn't stored in Git, for example. Aka, temporary folder.</p>

<p>Sometimes 3rd parties, like fonts, should be installed with <code>npm</code> or <code>bower</code> and deployed to SharePoint only partly, e.g. only a specific files out of numerous files of 3rd party package.</p>

<p>Build tools can be configured to copy some static assets in <code>./config/app.json</code> within the following parameters:</p>

<pre><code class="language-javascript">{
  ...
  // copyAssetsMap: Is an array of src/dist pairs opbects
  "copyAssetsMap": [{
    // src: Is an array of paths to folders or files
    // Folders and files are copied based on this array, 
    // subfolders are created automatically
    "src": [
      "./node_modules/datatables/media/images",
      "./src/images",
      "./src/scripts/modules/wysiwyg.js"
    ],
    "dist": "./dist" // Target destination location where files are copied
  }],
  ...
}
</code></pre>

<h4 id="buildoptionsbranding">Build options: Branding</h4>

<p><code>sp-build-tasks</code> supports branding build automation.</p>

<p>Basic branding settings are tweaked in <code>./config/app.json</code> within the following parameters:</p>

<pre><code class="language-javascript">{
  ...
  "masterpagePath": "masterpage/frankfurt.master",
    // Relative to publishing folder path to custom masterpage
    // Is used in `gulp masterpage:apply` task
  "logoPath": "images/logo.png",
    // Relative to publishing folder path to custom logo
    // Is used in `gulp masterpage:apply` and `gulp logo:apply` tasks
  "masterpageCodeName": "frankfurt",
    // Masterpage code name
  "platformVersion": "2016",
    // Masterpage platform version (2016, 2013, etc.)
  "masterpage": { 
    // Custom structure object which properties 
    // can be used while compiling masterpage's .hbs
    "copyright": {
      "year": "2017",
      "title": "Contoso intranet"
    }
  }
  ...
}
</code></pre>

<p>Masterpage sources should be placed in:</p>

<ul>
<li>src
<ul><li>masterpage</li>
<li>frankfurt.2016.hbs</li>
<li>frankfurt.2013.hbs</li></ul></li>
</ul>

<p>Where <code>frankfurt</code> is a <code>masterpageCodeName</code> sample, <code>2016</code> or <code>2013</code> parts are <code>platformVersion</code>'s. <br>
.hbs is a handlebars, masterpage .aspx's content should be copied to the .hbs initially. </p>

<h3 id="tasks">Tasks</h3>

<h4 id="gettingtaskslist">Getting tasks list:</h4>

<pre><code class="language-bash">gulp --tasks  
</code></pre>

<p>By doing this the tree of tasks with dependencies should be rendered in terminal window.</p>

<h5 id="config">Config</h5>

<pre><code class="language-bash">gulp config  
</code></pre>

<p>Inits SharePoint credentials prompt wizard. <br>
Wizard is implemented  <a href="https://github.com/koltyakov/node-sp-auth-config">node-sp-auth-config</a> library.</p>

<p>After config is done, auth settings are dumped to './config/private.json'.</p>

<p>Second run of the task checks './config/private.json' and do not prompt if it exists and all parameters for a specific are auth strategy are provided.</p>

<h5 id="pull">Pull</h5>

<pre><code class="language-bash">gulp pull  
</code></pre>

<p>Initiates download of all remote assets from <code>spFolder</code> to <code>./dist</code> folder. <br>
This task can be useful if one is intended to check if the assets in SharePoint had been changed since last publish or in migration scenarios when some assets are already created in SharePoint (with SharePoint Designer, for instance).</p>

<h5 id="buildfrontend">Build front-end</h5>

<pre><code class="language-bash">gulp build  
</code></pre>

<p>Build task combines multiple build actions, such as:</p>

<h6 id="bundlingscriptstypescriptjavascript">Bundling scripts (typescript, javascript)</h6>

<pre><code class="language-bash">gulp build:webpack  
</code></pre>

<h6 id="bundlingcustomstylesfromscss">Bundling custom styles from SCSS</h6>

<pre><code class="language-bash">gulp build:css-custom  
</code></pre>

<h6 id="copyingstaticresources">Copying static resources</h6>

<pre><code class="language-bash">gulp build:copy-assets  
</code></pre>

<h6 id="bundling3rdpartyscriptlibraries">Bundling 3-rd party script libraries</h6>

<pre><code class="language-bash">gulp build:js-libs  
</code></pre>

<h6 id="bundling3rdpartystylescsslibraries">Bundling 3-rd party styles (CSS) libraries</h6>

<pre><code class="language-bash">gulp build:css-libs  
</code></pre>

<h6 id="compilingmasterpagetemplate">Compiling masterpage template</h6>

<pre><code class="language-bash">gulp build:masterpage  
</code></pre>

<h6 id="compilinglayoutstemplates">Compiling layouts templates</h6>

<pre><code class="language-bash">gulp build:layouts  
</code></pre>

<h6 id="compilingcontenteditorsourceswebparts">Compiling content editor sources webparts</h6>

<pre><code class="language-bash">gulp build:webparts  
</code></pre>

<h5 id="publishpush">Publish (push)</h5>

<pre><code class="language-bash">gulp push  
</code></pre>

<p>Uploads and publishes <code>./dist</code> folder's content to remote <code>spFolder</code> in SharePoint. <br>
The task uses <a href="https://github.com/s-KaiNet/gulp-spsave">gulp-spsave</a> for delivering assets to SharePoint.</p>

<h5 id="watchingassets">Watching assets</h5>

<h6 id="standardwatch">Standard watch</h6>

<pre><code class="language-bash">gulp watch  
</code></pre>

<p>Watches local files for changes and initiates build and publishing of changed sources. <br>
The task watches for following sources: <br>
- src
  - masterpage
    - [watches masterpage .hbs]
    - layouts
      - [watches layouts.hbs files]
  - scripts
    - [watches for .ts files changes]
  - styles
    - [watches for .scss files changes]
  - webpartc
    - [watches for .hbs files changes]</p>

<h6 id="watchwithpagelivereload">Watch with page live-reload</h6>

<pre><code class="language-bash">gulp live  
</code></pre>

<p>Does the same as <code>gulp watch</code>, but also emits changed files paths within the live-reload local server. <br>
Implements socket proactive reload using <a href="https://github.com/koltyakov/sp-live-reload">sp-live-reload</a> library.</p>

<h5 id="deploymenthelpers">Deployment helpers</h5>

<h6 id="applycustommasterpage">Apply custom masterpage</h6>

<pre><code class="language-bash">gulp masterpage:apply  
</code></pre>

<p>Applyis custom masterpage to the SPWeb. </p>

<h6 id="restoreseattlemasterpage">Restore Seattle masterpage</h6>

<pre><code class="language-bash">gulp masterpage:restore  
</code></pre>

<h6 id="applycustomlogo">Apply custom logo</h6>

<pre><code class="language-bash">gulp logo:apply  
</code></pre>

<h6 id="livereloadinstall">Live-reload install</h6>

<pre><code class="language-bash">gulp reload:install  
</code></pre>

<p>Installs live-reload client script globally on SPWeb as a User ScriptLink custom action.</p>

<h6 id="livereloaduninstall">Live-reload uninstall</h6>

<pre><code class="language-bash">gulp reload:retract  
</code></pre>

<p>Remove live-reload client script custom action from SPWeb.</p>

<h5 id="other">Other</h5>

<h6 id="typescript">TypeScript</h6>

<p><strong>Compile</strong></p>

<pre><code class="language-bash">gulp tsc  
</code></pre>

<p>Compiles .ts files.</p>

<p><strong>Linting</strong></p>

<pre><code class="language-bash">gulp tslint  
</code></pre>

<p>Checks .ts files with TSLint.</p>

<h5 id="clean">Clean</h5>

<pre><code class="language-bash">gulp clean  
</code></pre>

<p>Deletes <code>./dist</code> folder. <br>
The task is used as a child in a build process to clean up <code>./dist</code> before building from sources.</p>

<h5 id="customtasks">Custom tasks</h5>

<p>Just in case if you need do more within Gulp tasks there is a capability of adding add-hoc scripts in './build/tasks' folder. <code>sp-build-tasks</code> reads all JavaScripts in the folder and registers the tasks. </p>

<p>The example of add-hoc task is below:</p>

<pre><code class="language-javascript">module.exports = (gulp, $) => {  
    'use strict';

    gulp.task('example', (cb) => {
        console.log('Example Gulp Task');
        cb();
    });
};
</code></pre>

<hr>

<p>Here we're, done with the configuration and build tasks. Now it's time to relax and create something valuable for the portal. <br>
Get ready for automation fun running tasks with understanding how to configure and extend the beast for your own project routines!</p></body></html>]]></content:encoded></item><item><title><![CDATA[Using JSOM (CSOM, SharePoint Client Side Object Model) in Node.js]]></title><description><![CDATA[<html><head></head><body><h2 id="intro">Intro</h2>

<p>It's not a secret that it's theoretically feasible to execute SharePoint Client Side Object Model in Node.js. Some folks found a way to master <a href="https://gist.github.com/lstak/2404924">JSOM in Node.js's context</a> around 5 years ago from now.</p>

<p>Unfortunately, there was no solid solution as a drop-in library. And you could</p></body></html>]]></description><link>/2017/06/05/using-jsom-csom-sharepoint-client-side-object-model-in-node-js/</link><guid isPermaLink="false">47f99d6a-383b-4b02-b962-76e3a00f460b</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[JSOM]]></category><category><![CDATA[API]]></category><category><![CDATA[TypeScript]]></category><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Mon, 05 Jun 2017 07:07:56 GMT</pubDate><media:content url="/content/images/2017/06/JsomNodeWide-1.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><h2 id="intro">Intro</h2>

<img src="/content/images/2017/06/JsomNodeWide-1.png" alt="Using JSOM (CSOM, SharePoint Client Side Object Model) in Node.js"><p>It's not a secret that it's theoretically feasible to execute SharePoint Client Side Object Model in Node.js. Some folks found a way to master <a href="https://gist.github.com/lstak/2404924">JSOM in Node.js's context</a> around 5 years ago from now.</p>

<p>Unfortunately, there was no solid solution as a drop-in library. And you could struggle for hours before the "hack" will work for you. And when you needed to switch to a different SharePoint environment with different authentication strategy and your were in trouble.</p>

<p>You might say, how about <a href="https://github.com/vgrem/CSOMNode">CSOMNode</a> project by Vadim Gremyachev, which is already a drop in library ready to use. Well, it's a nice library and it was the inspiration point for me, actually, but it is limited with SAML and Add-in Only authentication strategies and I'm not sure that guys have enough time to support the project with delivering new breaking features. At least the issue asking for NTLM authentication is unanswered for eight months, another issue with authentication also stays untouched. I can understand it as rough time limitations of the author for such side projects.</p>

<p>In my case, I needed the same exact authentication methods which are missed in CSOMNode. On other projects, I use <a href="https://www.npmjs.com/package/node-sp-auth">node-sp-auth</a>, which provides a plenty of different authentication strategies and have a wonderful support from the author.</p>

<p>Also I needed JSOM in Node.js functionality very urgently for one of recent tasks with integration testing.</p>

<p>My first idea was to contribute to CSOMNode and suggest or integrate <code>node-sp-auth</code> by myself and send a Pull Request. After spending some time with the project's code I understood that my PR won't likely be merged soon or at all. I know from my own experience that when an author has an opinion about his approaches, code style, structure, etc., you just can't provide too complex PR and breaking changes even if they are awesome. My changes were going to be such, I mean complex, it's up to you to decide if it's awesome. Also, I have an allergy for writing libraries in pure JavaScript lately and omitting linting rules. But that's my own personal requirement for the code that should be supported later on.</p>

<p>With all these circumstances in mind I started writing my own version of the library for landing JSOM into Node.js context with a variety of authentication mechanisms.</p>

<h2 id="jsominnodejs">JSOM in Node.js</h2>

<p>The algorithm of landing JSOM to Node in general is pretty simple: <br>
- Adjust global Node.js context to pretend to be a browser (<a href="https://github.com/koltyakov/sp-jsom-node/blob/master/src/JsomNode.ts#L75">in code</a>)
- Load and eval JSOM JavaScript files' content in a specific order (<a href="https://github.com/koltyakov/sp-jsom-node/blob/master/src/JsomNode.ts#L142">in code</a>)
- Patch some variables and object to eliminate a couple of issues (e.i. <a href="https://github.com/koltyakov/sp-jsom-node/blob/master/src/JsomNode.ts#L162">microsoft ajax</a>)
- Inject authentication headers into the requests to the server (<a href="https://github.com/koltyakov/sp-jsom-node/blob/master/src/JsomNode.ts#L179">in code</a>)</p>

<p>Mimic browser, loading JSOM JavaScripts and patching variables and object is a trivial part, and mostly had been taken from CSOMNode with some refactoring and conversion to TypeScript. You could check a specific parts in code.</p>

<p>Injecting authentication headers into the requests is really the most complex part.</p>

<p>JavaScript Client Side Object Model uses Microsoft Ajax library and XmlHttpRequest. What can I say?... I don't like their company much.</p>

<p>Initially I planned getting authentication headers and injecting them to all requests in <code>add_executingWebRequest</code> method.</p>

<pre><code class="language-javascript">clientContext.add_executingWebRequest((sender, e) => {  
    let headers = e.get_webRequest().get_headers();
    for (let header of Object.keys(auth)) {
        if (['Cookie', 'Authorization'].indexOf(header) !== -1) {
            headers[header] = auth[header];
        }
    }
});
</code></pre>

<p>As a result, requests are sent with custom headers.</p>

<p>And it worked... only to FedAuth cookies and Bearer authorization... and didn't for NTLM tokens for example.</p>

<p>The struggle was hard, really hard. I ended up with the idea that I should not use any XmlHttpRequest emulators and wrap my own proxy level into WebRequestManager's <code>executeRequest</code> method.</p>

<p>Original <code>Sys.Net._WebRequestManager.prototype.executeRequest</code> receives web request object and applies it to XmlHttpRequest.</p>

<p>In my <a href="https://github.com/koltyakov/sp-jsom-node/blob/master/src/JsomNode.ts#L179">implementation</a>, Sys.Net._WebRequestManager.prototype.executeRequest is completely rewritten to use <a href="https://www.npmjs.com/package/sp-request">sp-request</a>. It's in charge of injecting auth headers and X-RequestDigest, which works smoothly for almost any kind of auth, including NTML, ADFS and FBA.</p>

<h2 id="usingexamples">Using examples</h2>

<p>Oh, so much lyrics above. Let's start coding JSOM in Node.js without headache.</p>

<p>Let me introduce you <a href="https://github.com/koltyakov/sp-jsom-node"><code>sp-jsom-node</code></a> library, or JsomNode.</p>

<p><img src="https://raw.githubusercontent.com/koltyakov/sp-jsom-node/master/docs/imgs/JsomNode.demo.gif" alt="Using JSOM (CSOM, SharePoint Client Side Object Model) in Node.js"></p>

<p>First, we need a Node.js project and install the library:</p>

<pre><code class="language-bash">npm install sp-jsom-node --save  
</code></pre>

<p>After <code>sp-jsom-node</code> is installed, it can be used in TypeScript or JavaScript. I'm going to provide all examples in TypeScript and I assume you have TypeScript global modules (like, typescript, ts-node, tslint, etc.) installed.</p>

<p>Next, let's create an index.ts (or any) and paste in the following code snippet:</p>

<pre><code class="language-javascript">import { JsomNode } from 'sp-jsom-node';

(new JsomNode()).wizard().then((settings) => {

    // Here we are, ready fo JSOM

    const ctx = SP.ClientContext.get_current();
    const oWeb = ctx.get_web();

    ctx.load(oWeb);

    ctx.executeQueryAsync(() => {
        console.log(oWeb.get_title());
    }, (sender, args) => {
        console.log(args.get_message());
    });


}).catch(console.log);
</code></pre>

<p>This is the minimal setup without overwhelming configuration.</p>

<p>In this mode, without initial configuration, if we run <code>ts-node ./index.ts</code> we'll be prompted to target to a specific SharePoint site and provide credentials. A subsequent script run re-uses saved configuration parameters and doesn't prompt no more.</p>

<p>If you do not like wizards and prefer manual configuration, no problem:</p>

<pre><code class="language-javascript">import { JsomNode, IJsomNodeSettings } from 'sp-jsom-node';

let settings: any = require('./config/private.json');

let jsomNodeOptions: IJsomNodeSettings = {  
    siteUrl: settings.siteUrl,
    authOptions: {
        ...(settings as any)
    }
};

(new JsomNode(jsomNodeOptions)).init();

/// ... <<< JSOM can be used here
</code></pre>

<p>The project contains integration tests (I test recent libraries with SharePoint Online, SharePoint 2016 and 2013) and example for a quick start which can be downloaded for first experiments with the library.</p>

<h2 id="conclusion">Conclusion</h2>

<p>If you need JSOM in Node.js for any crazy or rational reasons and something prevented you from doing this, welcome on board with <code>sp-jsom-node</code>. And don't forget to comment about your use cases.</p>

<p>I truly hope the library will find its users and that it wasn't developed only for the tasks I needed to be solved.</p></body></html>]]></content:encoded></item><item><title><![CDATA[Using PnP JS Core outside a browser (Node.js environment)]]></title><description><![CDATA[<html><head></head><body><blockquote>
  <p>Expanding scopes of usage of favorite tools</p>
</blockquote>

<p>I <a href="/2016/09/09/sharepoint-pnp-javascript-core-components-deserve-more-attention/">wrote</a> about <a href="https://github.com/SharePoint/PnP-JS-Core">PnP JS Core</a> 9 month ago. In those post, I shared my experience of first steps with the library and decision to give it a shot on the projects.</p>

<p>And what can I say after these months? Now it's one</p></body></html>]]></description><link>/2017/05/18/using-pnp-js-core-outside-a-browser-node-js-environment/</link><guid isPermaLink="false">44738222-d385-43c0-af0c-4510859c05e6</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[PnP]]></category><category><![CDATA[REST]]></category><category><![CDATA[PnP JS Core]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Thu, 18 May 2017 07:01:43 GMT</pubDate><media:content url="/content/images/2017/05/sp-pnp-node-2.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><blockquote>
  <img src="/content/images/2017/05/sp-pnp-node-2.png" alt="Using PnP JS Core outside a browser (Node.js environment)"><p>Expanding scopes of usage of favorite tools</p>
</blockquote>

<p>I <a href="/2016/09/09/sharepoint-pnp-javascript-core-components-deserve-more-attention/">wrote</a> about <a href="https://github.com/SharePoint/PnP-JS-Core">PnP JS Core</a> 9 month ago. In those post, I shared my experience of first steps with the library and decision to give it a shot on the projects.</p>

<p>And what can I say after these months? Now it's one of the must have dependencies on any new front-end project I scaffold for SharePoint. I almost have forgotten when I needed to grab old fellow JSOM (sp.js) for the reason of communication with SharePoint API within a UI application. It works almost for anything available in REST API. There are some gaps and scenarios in the API when REST have no existing methods implementation (<a href="https://github.com/SharePoint/PnP-JS-Core/issues/415">Manage Metadata</a>, some areas of <a href="/2017/02/16/working-with-sharepoint-ups-in-node-js/">User Profiles Services</a>, <a href="https://github.com/SharePoint/PnP-JS-Core/issues/455">indexed properties</a>, etc.) though it's not something which you need very often in UI application. For the methods, what are there in the REST API, PnP JS Core is an awesome shiny tool.</p>

<p>With time, I faced a couple of project needs where I got to fetch some metadata and data within Node.js using REST where hands themselves started writing in PnP JS Core. Yes, I know that it's not a big deal to prepare REST endpoint URIs and some JSON packages for such tasks. But it's a question of reusability and convenience writing code using your favorite API wrapper.</p>

<p>Luckily, I was not along with such an idea and some folks already <a href="https://blogs.msdn.microsoft.com/patrickrodgers/2016/10/17/using-pnp-js-core-and-node-sp-auth/">experimented</a> with it and even created <a href="https://github.com/s-KaiNet/node-pnpjs-sample">examples</a> on GitHub. It was a matter of minutes to grab those concepts and successfully run PnP JS Core in Node.js on the server side.</p>

<p>The suggested method with "patching" global variables, request headers and fetch client worked perfectly on a production for a couple of different things, one of which is extracting metadata for almost 20 hundred different SharePoint artifact elements.</p>

<p>Month later, I faced a need to reuse the technique and not just once but for a number of times.</p>

<p>Well, it was a perfect time to wrap fetch client patching code into some reusable way and avoid copy & pasting between the projects. Said and done. I created a library named <a href="https://github.com/koltyakov/sp-pnp-node">sp-pnp-node</a>, which abstracts away any http request patching experience and allows minify extra code.</p>

<p>One can install dependency with NPM or Yarn:</p>

<p><strong>NPM</strong></p>

<pre><code class="language-bash">npm install sp-pnp-node --save  
</code></pre>

<p><strong>Yarn</strong></p>

<pre><code class="language-bash">yarn add sp-pnp-node --save  
</code></pre>

<p>Then start using it in server side JavaScript or TypeScript.</p>

<p><strong>Usage in TypeScript</strong></p>

<pre><code class="language-javascript">import { PnPNode } from 'sp-pnp-node';  
import { Web } from 'sp-pnp-js';

(new PnPNode()).init().then((settings) => {

    // Here goes PnP JS Core code
    let web: Web = new Web(settings.siteUrl);
    // ... do whatever you like with PnP JS Core

});
</code></pre>

<p><strong>Usage in ES6</strong></p>

<pre><code class="language-javascript">const PnPNode = require('sp-pnp-node').PnPNode;  
const pnp = require('sp-pnp-js');

(new PnPNode()).init().then((settings) => {

    // Here goes PnP JS Core code
    let web = new pnp.Web(settings.siteUrl);
    // ... do whatever you like with PnP JS Core

});
</code></pre>

<p>Three additional lines of code and you are in ready PnP JS Core'ing.</p>

<p>It's possible to define some extra settings, yet my number one idea was to make it as simple to use as possible. So, a new object instance of <code>PnPNode</code> can be created with a default settings by providing no configuration parameters in the code at all. What does that mean? How does the lib understand which environment and credentials to use? It will ask for authentication options in a wizard like way and will dump the inputs to a config file, it will even hash your password so it will not be there as a plain text unless you need it to.</p>

<p>Those who familiar with some other projects of myself knows I use <code>node-sp-auth</code> heavily for authentication in SharePoint when dealing with Node.js. To share similar user experience with auth configuration <a href="https://github.com/koltyakov/node-sp-auth-config">node-sp-auth-config</a> was integrated to this lib too. That is <code>node-sp-auth-config</code> in charge for asking and saving these settings.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Once again, I recommend PnP JS Core for the stuff it was designed for. Nine months of constant usage of the library is a strong argument.</p>

<p>Browser is not the only home for PnP JS Core and with tools like <a href="https://github.com/koltyakov/sp-pnp-node">sp-pnp-node</a> it can be smoothly executed in Node.js (console apps, timer jobs, microservices, electron apps, all of these are benevolent to it).</p></body></html>]]></content:encoded></item><item><title><![CDATA[Working with SharePoint UPS in Node.js]]></title><description><![CDATA[<html><head></head><body><p>This article is a logical continuation of my <a href="http://blog.arvosys.com/2017/02/15/working-with-sharepoint-mmd-in-node-js/">previous post</a> where I described Node.js way of dealing with Managed Metadata services. This post covers some problems of SharePoint API usage when working with another super popular service the User Profiles Services (UPS).</p>

<p>User Profiles services' REST API is much</p></body></html>]]></description><link>/2017/02/16/working-with-sharepoint-ups-in-node-js/</link><guid isPermaLink="false">10e45d85-57b2-4235-aa83-e749998e40b9</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[API]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[SOAP]]></category><category><![CDATA[JSOM]]></category><category><![CDATA[REST]]></category><category><![CDATA[UPS]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Thu, 16 Feb 2017 13:55:57 GMT</pubDate><media:content url="/content/images/2017/02/UPS-node.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2017/02/UPS-node.png" alt="Working with SharePoint UPS in Node.js"><p>This article is a logical continuation of my <a href="http://blog.arvosys.com/2017/02/15/working-with-sharepoint-mmd-in-node-js/">previous post</a> where I described Node.js way of dealing with Managed Metadata services. This post covers some problems of SharePoint API usage when working with another super popular service the User Profiles Services (UPS).</p>

<p>User Profiles services' REST API is much richer than MMD's one, at least it exists. UPS's PeopleManager and ProfileLoader covers a lot of <a href="https://msdn.microsoft.com/en-us/library/office/dn790354.aspx">functionality</a>. Unfortunately, not each and every CSOM capability is there at the place. Most methods expose automation connected with a personal profile, most are getters but not the setters.</p>

<p>In our scenario, we're going to build a mechanism for writing user profile properties in Node.js. As it was with MMD, we'll be using CSOM/JSOM and SOAP capabilities to enrich program interface on server-side JavaScript field. Let's assume that there is a 3rd party data source with properties which should be synchronized with user profiles, synchronization should run in a schedule and Node.js is the only option to perform operations.</p>

<h3 id="soap">SOAP</h3>

<p>Legacy SOAP API is hidden inside /<em>vti</em>bin/UserProfileService.asmx endpoint. The service has a variety of methods, actually, there are 43 methods. Pretty nice, isn't it?</p>

<p>The method we're interested in now is ModifyUserPropertyByAccountName. It allows writing single and multivalued properties to the specific user profile.</p>

<p>Just like in MMD's scenario, <a href="https://github.com/s-KaiNet/sp-request">sp-request</a> and <a href="https://github.com/s-KaiNet/node-sp-auth">node-sp-auth</a> will be in charge of the communication layer over the wires and protocols.</p>

<p>Let's dive deeper with ModifyUserPropertyByAccountName method. SOAP package format is:</p>

<pre><code class="language-xml"><?xml version="1.0" encoding="utf-8"?>  
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"
   xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
    <soap:Body>
        <ModifyUserPropertyByAccountName
   xmlns="http://microsoft.com/webservices/SharePointPortalServer/UserProfileService">
            <accountName>{{ accountName }}</accountName>
            <newData>
                {{#newData}}
                <PropertyData>
                    <IsPrivacyChanged>{{ isPrivacyChanged }}</IsPrivacyChanged>
                    <IsValueChanged>{{ isValueChanged }}</IsValueChanged>
                    <Name>{{ name }}</Name>
                    <Privacy>{{ privacy }}</Privacy>
                    <Values>
                        {{#values}}
                        <ValueData>
                            <Value xsi:type="xsd:string">{{ this }}</Value>
                        </ValueData>
                        {{/values}}
                    </Values>
                </PropertyData>
                {{/newData}}
            </newData>
        </ModifyUserPropertyByAccountName>
    </soap:Body>
</soap:Envelope>  
</code></pre>

<p>The dynamic part is:</p>

<ul>
<li>accountName - full account name for user profile (<code>i:0#.f|membership|user.name@contoso.com</code>)</li>
<li>newData - array of properties
<ul><li>name - property name</li>
<li>values - array of property values</li></ul></li>
</ul>

<p>After wrapping SOAP request it can be called like this:</p>

<pre><code class="language-javascript">let Screwdriver = require('sp-scredriver');  
let context = require('./path_to_private_settings');  
let screw = new Screwdriver(context);

let data = {  
    baseUrl: context.siteUrl,
    accountName: config.ups.accountName,
    newData: [{
        isPrivacyChanged: false,
        isValueChanged: true,
        privacy: 'NotSet',
        name: 'SPS-Birthday',
        values: [ '10.03' ]
    }, {
        isPrivacyChanged: false,
        isValueChanged: true,
        privacy: 'NotSet',
        name: 'SPS-Department',
        values: [ 'Administration' ]
    }]
};

screw.ups.modifyUserPropertyByAccountName(data)  
    .then(response => {
        console.log('Response:', response.body);
    })
    .catch(err => console.log('Error:', err.message));
</code></pre>

<p><a href="https://github.com/koltyakov/sp-screwdriver/blob/master/test/ups-test.js">Open on GitHub</a></p>

<p>Here we're done with the SOAP, but I do not like SOAP actually, so I need yet another alternative, which is CSOM way.</p>

<h3 id="csomjsom">CSOM/JSOM</h3>

<p>In CSOM API there are who methods for writing properties setSingleValueProfileProperty and setMultiValuedProfileProperty. To master them in Node.js application, we're doing the hack described in the previous <a href="http://blog.arvosys.com/2017/02/15/working-with-sharepoint-mmd-in-node-js/">post</a>:</p>

<ul>
<li>executing JSOM version of the script in chrome</li>
<li>and watching the traffic in fiddler.</li>
</ul>

<p>So, for example, JSOM script is:</p>

<pre><code class="language-javascript">var clientContext = new SP.ClientContext.get_current();  
var peopleManager = new SP.UserProfiles.PeopleManager(clientContext);

peopleManager.setMultiValuedProfileProperty(  
   `i:0#.f|membership|${_spPageContextInfo.userLoginName}`, 
   'SPS-Skills', 
   [ 'Git', 'Node.js', 'JavaScript', 'SharePoint' ]
);

clientContext.executeQueryAsync(  
    () => console.log('Done'), 
    (sender, args) => console.log('Error:', args.get_message())
);
</code></pre>

<p>After a call with use of fiddler, we're getting our client side object model package:</p>

<pre><code class="language-xml"><Request xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009" SchemaVersion="15.0.0.0" LibraryVersion="15.0.0.0" ApplicationName="Javascript Library">  
    <Actions>
        <ObjectPath Id="82" ObjectPathId="81" />
        <Method Name="SetMultiValuedProfileProperty" Id="83" ObjectPathId="81">
            <Parameters>
                <Parameter Type="String">{{ accountName }}</Parameter>
                <Parameter Type="String">{{ propertyName }}</Parameter>
                <Parameter Type="Array">
                    {{#propertyValues}}
                    <Object Type="String">{{ this }}</Object>
                    {{/propertyValues}}
                </Parameter>
            </Parameters>
        </Method>
    </Actions>
    <ObjectPaths>
        <Constructor Id="81" TypeId="{cf560d69-0fdb-4489-a216-b6b47adf8ef8}" />
    </ObjectPaths>
</Request>  
</code></pre>

<p>Where:</p>

<ul>
<li>accountName - full account name for user profile (<code>i:0#.f|membership|user.name@contoso.com</code>)</li>
<li>propertyName - property name</li>
<li>propertyValues - array of property values</li>
</ul>

<p>And the usage in Node.js is possible like:</p>

<pre><code class="language-javascript">let Screwdriver = require('sp-scredriver');  
let context = require('./path_to_private_settings');  
let screw = new Screwdriver(context);

let data = {  
    baseUrl: context.siteUrl,
    accountName: config.ups.accountName,
    propertyName: 'SPS-Skills',
    propertyValues: [ 'Git', 'Node.js', 'JavaScript', 'SharePoint' ]
};

screw.ups.setMultiValuedProfileProperty(data)  
    .then(response => {
        console.log('Response:', JSON.parse(response.body));
    })
    .catch(err => console.log('Error:', err.message));
</code></pre>

<p>setSingleValueProfileProperty is almost identical and even simpler.</p>

<p>Sources with implementation can be found on <a href="https://github.com/koltyakov/sp-screwdriver/blob/master/src/api/ups.js">GitHub</a>. It's a part of <a href="https://github.com/koltyakov/sp-screwdriver">sp-screwdriver</a> library, library, which was published as an example for similar tasks of extending Node.js apps and services to deal with SharePoint's SOAP and CSOM/JSOM APIs as well.</p></body></html>]]></content:encoded></item><item><title><![CDATA[Working with SharePoint MMD in Node.js]]></title><description><![CDATA[<html><head></head><body><p>SharePoint REST API is nice, powerful and universal to deal with, but sometimes you face barriers and recall that the desired API is absent in REST, yet, at the same time, is a part of CSOM/JSOM. It's not an issue when your code lives in a context of a</p></body></html>]]></description><link>/2017/02/15/working-with-sharepoint-mmd-in-node-js/</link><guid isPermaLink="false">648aa6f7-ebd5-4810-8100-a9f35e6a1ee4</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[API]]></category><category><![CDATA[SOAP]]></category><category><![CDATA[JSOM]]></category><category><![CDATA[MMD]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Wed, 15 Feb 2017 15:15:54 GMT</pubDate><media:content url="/content/images/2017/02/SharePoint-MMD-Screwdriver.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2017/02/SharePoint-MMD-Screwdriver.png" alt="Working with SharePoint MMD in Node.js"><p>SharePoint REST API is nice, powerful and universal to deal with, but sometimes you face barriers and recall that the desired API is absent in REST, yet, at the same time, is a part of CSOM/JSOM. It's not an issue when your code lives in a context of a page, but what if not? C# CSOM will be the most obvious answer probably. But what if you are limited in choice language to use or a runtime environment, in other words, when .Net is not an option?n?</p>

<p>In a context of this story, the limitations are Node.js and JavaScript. And the task is to own a basic layer of functionality for manipulating Managed Metadata (Taxonomy), such options as:</p>

<ul>
<li>Get child terms in a term set</li>
<li>Get child terms in a parent term</li>
<li>Get a specific term</li>
<li>Add new term</li>
<li>Update a term</li>
<li>Deprecate a term</li>
<li>Get all terms (for relatively small dictionaries)</li>
</ul>

<p>The easiest solution for some basic operations can be SOAP services. Yes, SharePoint SOAP services are deprecated and they smell like mammoth fossils. But still there and work.</p>

<p>There is a SOAP service for dealing with MMD <code>/_vti_bin/TaxonomyClientService.asmx</code>. Let's take a look at it. The service represents the following methods:</p>

<ul>
<li>AddTerms</li>
<li>GetChildTermsInTerm</li>
<li>GetChildTermsInTermSet</li>
<li>GetKeywordTermsByGuids</li>
<li>GetTermSets</li>
<li>GetTermsByLabel</li>
</ul>

<p>One can consume these in Node.js using almost any http request module with authentication cookie encapsulation into request headers. Likely, there is no need to figure out in low level transport, all these authentication and SharePoint requests libraries exist and are here in our disposal, abstracting scary moments away. I'm describing <a href="https://github.com/s-KaiNet/sp-request">sp-request</a> with <a href="https://github.com/s-KaiNet/node-sp-auth">node-sp-auth</a>.</p>

<p><code>sp-request</code> module can easily talk to SharePoint SOAP service like this:</p>

<pre><code class="language-javascript">const baseUrl = 'https://contoso.sharepoint.com/sites/site';  
let authObject = { ... }; // node-sp-auth authentication format  
let request = require('sp-request').create(authObject);  
let headers = {};

let soapBody = `  
   ... // XML SOAP body for a specific method
`;

headers['Accept'] = 'application/xml, text/xml, */*; q=0.01';  
headers['Content-Type'] = 'text/xml;charset=\"UTF-8\"';  
headers['X-Requested-With'] = 'XMLHttpRequest';  
headers['Content-Length'] = soapBody.length;

request.post(baseUrl + '/_vti_bin/TaxonomyClientService.asmx', {  
  headers: headers,
  body: soapBody,
  json: false
})
  .then(response => {
    // Proceed the responce object
  })
  .catch(err => console.log(err));
</code></pre>

<p>It can be tricky to figure out with SOAP packages for some methods sometimes, some SOAP operations descriptions are not perfect. Good thing is that any related to SharePoint SOAP services information also is relevant for Node.js use cases.</p>

<p>I wrapped some methods in an library with the name <a href="https://github.com/koltyakov/sp-screwdriver">sp-screwdriver</a>. It is not for production purposes as-is, it can act as a start point or example how to consume APIs.</p>

<p>Here we're standing in front of another wall, those SOAP interfaces are sometimes featureless and offer only a limited number of actions, it's true with MMD at least. What about editing existing terms, how to request all them in a single call, how to do more?</p>

<p>Here I use a little hack, which includes the following workflow:</p>

<ul>
<li>Create the desired operation in JSOM</li>
<li>Run it in the browser monitoring actual request body in fiddler </li>
<li>Parse a package which was generated and sent to <code>/_vti_bin/client.svc/ProcessQuery</code></li>
<li>Re-create the package for re-usability and wrap it inside a Node.js method talking to client.svc</li>
</ul>

<p>For example, request, to set term name, looks like:</p>

<pre><code class="language-xml"><Request xmlns="http://schemas.microsoft.com/sharepoint/clientquery/2009"  
      SchemaVersion="15.0.0.0" LibraryVersion="15.0.0.0" 
      ApplicationName="Javascript Library">
    <Actions>
        <SetProperty Id="166" ObjectPathId="157" Name="Name">
            <Parameter Type="String">{{ newName }}</Parameter>
        </SetProperty>
    </Actions>
    <ObjectPaths>
        <StaticMethod Id="146" 
           Name="GetTaxonomySession" 
           TypeId="{981cbc68-9edc-4f8d-872f-71146fcbb84f}" />
        <Property Id="149" ParentId="146" Name="TermStores" />
        <Method Id="151" ParentId="149" Name="GetByName">
            <Parameters>
                <Parameter Type="String">{{ serviceName }}</Parameter>
            </Parameters>
        </Method>
        <Method Id="154" ParentId="151" Name="GetTermSet">
            <Parameters>
                <Parameter Type="String">{{ termSetId }}</Parameter>
            </Parameters>
        </Method>
        <Method Id="157" ParentId="154" Name="GetTerm">
            <Parameters>
                <Parameter Type="String">{{ termId }}</Parameter>
            </Parameters>
        </Method>
    </ObjectPaths>
</Request>  
</code></pre>

<p>Some comments to the format:</p>

<ul>
<li>Library version was changed to <code>15.0.0.0</code> to support backwards compatibility with On-Premises SharePoint 2013, as well as SharePoint 2016 and Online.</li>
<li>Some redundant tags should be deleted from the package received in fiddler (it's almost clear from the start what is redundant when observing the package).</li>
<li>IDs represent the flow or chain and reflect the CSOM sequence. They are different from a request to request, but if to freeze them static and request again and again request works. So I decided to leave IDs static.</li>
<li>Parameters in {{ doubleCurlyBraces }} are dynamic, they replaced in runtime with actual values by JavaScript code. Package for sure should not include any {{ }}. It's an artifact of Handlebars templating engine used.</li>
</ul>

<p>getAllTerms, setTermName and deprecateTerm example wrappers can be found in <a href="https://github.com/koltyakov/sp-screwdriver/blob/master/src/api/mmd.js">sp-screwdriver</a> library sources on GitHub.</p>

<p>After the wrapper methods are implemented, the usage can be straightforward:</p>

<pre><code class="language-javascript">let Screwdriver = require('sp-scredriver');  
let context = require('./path_to_private_settings');  
let screw = new Screwdriver(context);

let data = {  
    baseUrl: context.siteUrl,
    serviceName: config.mmd.serviceName,
    termSetId: config.mmd.termSetId,
    properties: [
        'Id', 'Name', 'Description', 'CustomProperties',
        'IsRoot', 'IsDeprecated', 'PathOfTerm',
        'IsAvailableForTagging', 'Parent'
    ]
};

screw.mmd.getAllTerms(data)  
    .then(response => {
        let results = JSON.parse(response.body);
        console.log("Response:", results);
    })
    .catch(err => console.log('Error:', err.message));
</code></pre>

<p>For myself, it was a nice way extending Node.js solutions capabilities to use not only the REST services but CSOM too. The approach was used on a couple of projects with Web Jobs, proceeding information in SharePoint, including MMD.</p>

<p>Also, working with MMD directly within Node.js code was viable in a recent Electron application I got to develop.</p>

<p>The article doesn't try to say that anyone should use Node.js for similar purposes as I do, as the same can be done in .Net, actually it should. But, at the same time, there are cases where it is nice to have an ability of extending server-side JavaScript to consume not only the REST API, but potentially any CSOM/JSOM functionality. </p></body></html>]]></content:encoded></item><item><title><![CDATA[SharePoint client side development with Live Reload]]></title><description><![CDATA[<html><head></head><body><p>We're getting used to modern SharePoint (client side) development day by day. It transforms into some sort of a hybrid of Visual Studio Code'ing, Gulp tasks, and Chrome Dev Tools debugging and tweaks.</p>

<p>More and more features from the funky front-end development are here at our disposal. Yet, there was</p></body></html>]]></description><link>/2016/11/05/sharepoint-client-side-development-with-live-reload/</link><guid isPermaLink="false">e3276611-dc06-42b9-9a01-5e695e111cd6</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[Gulp]]></category><category><![CDATA[Toolchain]]></category><category><![CDATA[Live Reload]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Fri, 04 Nov 2016 23:44:19 GMT</pubDate><media:content url="/content/images/2016/11/SharePointLiveReload.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2016/11/SharePointLiveReload.png" alt="SharePoint client side development with Live Reload"><p>We're getting used to modern SharePoint (client side) development day by day. It transforms into some sort of a hybrid of Visual Studio Code'ing, Gulp tasks, and Chrome Dev Tools debugging and tweaks.</p>

<p>More and more features from the funky front-end development are here at our disposal. Yet, there was one which has been missed and desired by some engineers. You might have heard about BrowserSync, have you? It is a module which can be injected into the page(s) and watches for changes for instantaneous page reload or scripts reload. A developer saves a file in the editor and sees the result applied right away.</p>

<p>As we know, SharePoint has its nuances, which prevents BrowserSync from efficient working. Luckily there is an alternative now.</p>

<p>Recently I've wrapped up the technique we have been using in our team for last months into the NPM module - <a href="https://github.com/koltyakov/sp-live-reload">sp-live-reload</a>.</p>

<p>With <code>sp-live-reload</code> it's possible to save a local client side file, such as javascript, css, html (source for content editor web part) with immediate change in open browsers tabs without a necessity for manual page refresh:</p>

<p><img src="http://koltyakov.ru/images/LiveReloadSimpleDemo.gif" alt="SharePoint client side development with Live Reload"></p>

<p>To make it work a developer can install the module with use of NPM command:</p>

<pre><code class="language-bash">npm install sp-live-reload --save-dev  
</code></pre>

<p>And then use the live reload in Gulp tasks as shown in examples on the project page.</p>

<p>We use it in the combination with <a href="http://github.com/s-KaiNet/gulp-spsave">SPSave</a>, the module which makes files upload and publishing to SharePoint transparent. Any <a href="http://github.com/koltyakov/sp-live-reload#watch-with-live-reload-gulp-spsync">alternatives</a> will work as well if emitted to the client path is correct.</p>

<pre><code class="language-javascript">var gulp = require('gulp');  
var spsave = require("gulp-spsave");  
var watch = require('gulp-watch');  
var through = require('through2');  
var LiveReload = require('sp-live-reload');

var config = require('./gulp.config');

gulp.task("watch-assets", function () {  
    console.log("Watch with reload is initiated.");
    console.log("Make sure that monitoring script is provisioned to SharePoint.");
    var liveReload = new LiveReload(config);
    liveReload.runServer();
    return watch(config.watchAssets, function (event) {
        console.log(event.path);
        gulp.src(event.path, {
            base: config.watchBase
        }).pipe(spsave(config.spsaveCoreOptions, config.spsaveCreds))
        .pipe(through.obj(function (chunk, enc, cb) {
            var chunkPath = chunk.path;
            liveReload.emitUpdatedPath(chunkPath);
            cb(null, chunk);
        }));
    });
});
</code></pre>

<p>The most controversial moment is how to deliver a live reload client script to SharePoint. Some possible issues are connected with that. As the environment can be shared between different persons.</p>

<p>There are following assumptions taken in mind:</p>

<ul>
<li>Live reload is actual in a development environment (less on a test, and almost never on the production)</li>
<li>There are limited developers on a specific development environment to conflict with each other</li>
<li>There is a variety of different browsers which should be supported by the reloading module</li>
</ul>

<p>With this being said, let me describe the approach:</p>

<ul>
<li>There are two options for delivering live reload client script to SharePoint:
<ul><li>Manual, when watch task is running it provides a URL to the script</li>
<li>Automated, a special gulp task exists for provisioning user custom action with script source </li></ul></li>
<li>Live reload script references for a localhost running server to receive information about updates, a developer who aren't running live reload task and doing something in the console just see one 404 error for a page load (this bothers me a bit, but it's possible to live with that)</li>
<li>Custom action can be easily retracted with another gulp task after the development session is finished to avoid any hassles</li>
<li>When two or more developers are "live watching" on the same site collection only one custom action is created, so all developers should share the same settings for the protocol and port, use default if possible</li>
</ul>

<p>A few words about the architectural implementation. Client and watch server use <a href="http://socket.io/">Socket.io</a> as a transport layer. All the browsers which are supported with Socket.io and SharePoint are automatically supported for live reload. <br>
The live reload server is running inside some watching task (gulp or other), on change and deliver events the server emits the message with the relative path for the resource in SharePoint which has been updated. <br>
The live reload client receives the messages from the server and checks if any resource is on the page. The client takes in mind SharePoint related features, like CEWP's source content. Also, there will be a support for a masterpage update and page layout update detection. As well as a community voice, as the module is extendable and open sourced.</p>

<p>Live reload works with On-Premises SharePoint installations (2016 and 2013) and SharePoint Online. Yet with SharePoint Online or any running over HTTPS some additional afford is needed to generate SSL certificate and add import it to trusted. But it worth it!</p>

<p><code>sp-live-reload</code> also is integrated into <a href="https://github.com/koltyakov/generator-sppp">generator-sppp</a> so you can use Yeoman generator to check it in action.</p></body></html>]]></content:encoded></item><item><title><![CDATA[SharePoint PnP JavaScript Core Components  deserve more attention]]></title><description><![CDATA[<html><head></head><body><p>I've been eschewed <a href="http://github.com/OfficeDev/PnP-JS-Core">PnP-JS-Core</a> for a long time and preferred to use JSOM or plain REST calls with the use of jQuery.ajax or SP.RequestExecutor. "Why do I need any wrappers or helpers for the API stuff which can be an additional point of failure?", I asked myself a</p></body></html>]]></description><link>/2016/09/09/sharepoint-pnp-javascript-core-components-deserve-more-attention/</link><guid isPermaLink="false">1f49b68e-5af0-433f-8028-7096a9ff76bc</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Toolchain]]></category><category><![CDATA[REST]]></category><category><![CDATA[API]]></category><category><![CDATA[sp-rest-proxy]]></category><category><![CDATA[PnP]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Fri, 09 Sep 2016 12:04:00 GMT</pubDate><media:content url="/content/images/2016/09/PnP-JS-Core_banner-2.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2016/09/PnP-JS-Core_banner-2.png" alt="SharePoint PnP JavaScript Core Components  deserve more attention"><p>I've been eschewed <a href="http://github.com/OfficeDev/PnP-JS-Core">PnP-JS-Core</a> for a long time and preferred to use JSOM or plain REST calls with the use of jQuery.ajax or SP.RequestExecutor. "Why do I need any wrappers or helpers for the API stuff which can be an additional point of failure?", I asked myself a couple of times putting PnP-JS-Core aside from learning.</p>

<p>But there was an opportunity this week to dive into the library and estimate expediency of its usage on a next project. The first fresh glance at it created a new and rather a positive attitude. First of all, it is made with the toolchain I love, and there are so many familiar faces in its contributors group, I didnt even know to be related to the project. That was a good sign so I started.</p>

<h2 id="whatisit">What is it</h2>

<p>PnP-JS-Core is a part of Office 365 Developer Patterns and Components for JavaScripting in SharePoint.</p>

<p>It is a wrapper over RESTful API and a bit more. PnP JS Core provides a fluent JS API simplifying REST calls to SharePoint API.</p>

<h2 id="stackproject">Stack & Project</h2>

<p>Yes, its made with the use of all of that shiny technologies we use on the most modern web projects: JavaScript (TypeScript), Gulp, NPM, Typings, Git, Linting, Serve and cool automation. Its easy to understand the project structure, logic and contribute.</p>

<p>It is not necessary to investigate the source, but a lot of questions can be solved by checking the code and <a href="http://github.com/OfficeDev/PnP/tree/dev/Samples/SharePoint.pnp-js-core">samples</a>. In the end, PnP-JS-Core is not something complex to learn at all.</p>

<h2 id="usage">Usage</h2>

<p>PnP-JS-Core can be <a href="http://github.com/OfficeDev/PnP-JS-Core/wiki/Install-and-Use">installed</a> with the use of NPM or Bower. The library can be used in TypeScript project or referenced as any other JS library and consumed on a page or browser console.</p>

<p>PnP-JS-Core uses fetch protocol and ES6 promises, thats why to make it work in IE, polyfills got to be loaded first. It is important to note, otherwise, if this part in documentation was skipped, one would be wondering What the heck, it doesnt work in IE? What is that error message in the console, saying "'Headers' is undefined?". But keep calm, PnP works perfectly in IE and Edge with es-promise and fetch polyfills.</p>

<h2 id="syntax">Syntax</h2>

<p>PnP-JS-Core has a base object <code>pnp</code> in case of default TypeScript import and <code>$pnp</code> if there is a pnp.js reference on a page and you are writing plain JS in a console or Chrome snippets.</p>

<p>REST calls, with the use of the PnP, can be constructed via fluent API chains with a promise initiator at the end of the statement.</p>

<p>For example, lets take some basic REST endpoint: <code>/_api/web/lists/getByTitle('CustomList')/items</code> call and reproduce it with the use of pnp:</p>

<pre><code class="language-javascript">$pnp.sp.web 
  .lists.getByTitle('ListTitle').items 
  .get() 
  .then(function(items) { 
    // all items are in the `items` array 
  });
</code></pre>

<p>$pnp.sp.web.lists.getByTitle('Custom01').items  is a constructor which builds endpoints URI.</p>

<p>IntelliSense helps during the process, so you can be even not aware of REST reference or at least have a bad memory and not necessarily remember the endpoints.</p>

<p>Yet, I highly recommend to have a strong understanding of <a href="http://msdn.microsoft.com/en-us/library/office/jj860569.aspx">REST API reference</a> and plan to receive all the fruits that PnP provide only after or use both during the learning curve of course.</p>

<p>When a fluent call is described, <code>get</code> method should be placed to initiate a query to a server. <code>Get</code> method and some others return a promise, that should be chained with <code>then</code> and <code>catch</code> to treat the results.  </p>

<p>Fluent API is really a piece of gold, all that <code>$select</code>, <code>$filter</code>, <code>$extend</code>, <code>$top</code>, etc. parameters are there as helper methods as well. The same is relevant for REST API properties and methods. But not everything is implemented in the current version. So its good to compare REST reference and PnP features if you feel like something is missing.</p>

<p>For example, Ive found myself unable to get a list by its URL, which I accept as the only reasonable way to communicate with lists and libraries in the code (as display title can be changed anytime in the UI and GUIDs-based code is complex to maintain and is not reasonable too, as IDs will be different from deploy to deploy for the same business objects). But less than in a half an hour I managed to fork and implement <code>pnp.sp.web.getList</code> method representation for <code>/_api/web/getlist(/sites/site/web/list/name)</code> and create a pull request for this.</p>

<p>Thats the power of open source.</p>

<h2 id="batches">Batches</h2>

<p>The well-known fact that REST API is very <code>chatty</code> (over the network) one. Sometimes JSOMs pros argument over REST says that by queueing some OM queries definitions into one physical executeQueryAsync call you can make an application faster. That is definitely true. But did you know that REST also has such tricks in O365 and SharePoint 2016. That is /_api/$batch endpoint.</p>

<p>PnP provides a great simplification for batch REST queries. Any query can be placed in batch call and retrieved inside one single batch execute.</p>

<pre><code class="language-javascript">var batchResults = [];  
var batch = new $pnp.sp.createBatch();  
$pnp.sp.web.getList('/sites/dev01/lists/custom01').items.inBatch(batch).get().then(function(d) {
  batchResults.push({ 
    custom01: d 
  });
});
$pnp.sp.web.getList('/sites/dev01/lists/custom02').items.inBatch(batch).get().then(function(d) {
  batchResults.push({ 
    custom02: d 
  });
});
for (var i = 0, len = 10; i < len; i += 1) {  
  $pnp.sp.web.getList('/sites/dev01/lists/custom03').inBatch(batch).items.add({ 
    Title: 'Item ' + i 
  });
}
batch.execute().then(function() {  
  console.log("All is done!", batchResults);
});
</code></pre>

<p>I was really surprised when discovered such a powerful and simple capability.</p>

<p>Unfortunately, REST batches arent supported in On-Prem versions before 2016 version.</p>

<h2 id="conclusion">Conclusion</h2>

<p>There was so much hype around PnP during last few years, but most people (developers or course), with whom I discussed PnP in general, never dived inside it at all, at the same time, were constantly mentioning it as a buzzword on different SP events.</p>

<p>At last, Ive touched some part of the PnP projects from the JS world side personally and can say it louder that it is a very interesting library, its worth learning and I will definitely include it in the next UI project.</p>

<h3 id="upd">UPD:</h3>

<p>I've also tried PnP-JS-Core with <a href="http://github.com/koltyakov/sp-rest-proxy">sp-rest-proxy</a> and it works! :)</p>

<p><img src="https://media.licdn.com/mpr/mpr/AAEAAQAAAAAAAAj0AAAAJGVhN2VkMDlmLWY0NDItNDVjYS05MTk5LWE1NjFiZWRiOWZhNg.png" alt="SharePoint PnP JavaScript Core Components  deserve more attention"></p>

<p>* This gonna work for GET calls only for now, due to the way sp-rest-proxy and pnp deal with Request Digest on a page.</p></body></html>]]></content:encoded></item><item><title><![CDATA[SharePoint REST API proxy for local serve in Node.js]]></title><description><![CDATA[<html><head></head><body><p>On the recent webcast dedicated to SharePoint Framework hosted by Rencore (SPFx Deep Dive Webinar on Wednesday, 31th of August) and driven by Bill Baer mostly, there were some interesting ideas, recommendations, and thoughts.</p>

<p>As for me this "dive" was not so deep and actually looked more like SharePoint platform</p></body></html>]]></description><link>/2016/09/03/sharepoint-rest-api-proxy-for-local-serve-in-node-js/</link><guid isPermaLink="false">734ab271-1b1e-450a-b1cf-5f4c31604dda</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[Toolchain]]></category><category><![CDATA[REST]]></category><category><![CDATA[Express]]></category><category><![CDATA[API]]></category><category><![CDATA[sp-rest-proxy]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Sat, 03 Sep 2016 12:01:00 GMT</pubDate><media:content url="/content/images/2016/09/RestProxyExample-1.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2016/09/RestProxyExample-1.png" alt="SharePoint REST API proxy for local serve in Node.js"><p>On the recent webcast dedicated to SharePoint Framework hosted by Rencore (SPFx Deep Dive Webinar on Wednesday, 31th of August) and driven by Bill Baer mostly, there were some interesting ideas, recommendations, and thoughts.</p>

<p>As for me this "dive" was not so deep and actually looked more like SharePoint platform history, toolchain overview and some scratching the surface showing a couple of the examples, but it's also a good stuff as timeframes were limited.</p>

<p>One of the coolest thing about SPFx is a capability to run <code>gulp serve</code>, after which you'll find yourself in local workbench ready to add client web parts on a modern page emulator and test them in action.</p>

<p><img src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAg0AAAAJDExYmQ1YjkzLWQ3YTItNGNjZC1iNzcxLWI4Mjg2OTUxNTQzMA.png" alt="SharePoint REST API proxy for local serve in Node.js"></p>

<p>One of the downsides of such local testing and debug is that you should deal with a mock generated artificial data. Maybe it only for now, maybe I understood incorrectly. But I consider that the real data is vital in many cases and real SharePoint API availability during such runtime can save hours of work and resolve tons of hassles.</p>

<p>I'm more than sure that later on real SharePoint API and data will be available locally within the workbench. This availability could be limited at least with REST API.</p>

<p>Why I'm so sure? Because it took me a single Friday night to create a REST API proxy with Node.js and Express, which allows running an application locally or on Node.js hosted server, which is actually the same, in other words, is not in the context of SharePoint page.</p>

<p>In such local web application page, without any deployment to SharePoint, one can execute GET or POST ajax call, let's say <code>/_api/web/lists</code>, which responses with the result as if an ajax call was on ShatePoint site page <code>~site/_api/web/lists</code>.</p>

<p><img src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAlYAAAAJGRiNjU3YjNjLWY0NzYtNDQxNS04ZTYzLWQ5NGQwNzBlOWExOA.png" alt="SharePoint REST API proxy for local serve in Node.js"></p>

<p>Any GET or POST call is routed to the real SharePoint tenant under specified user credentials, defined in the configuration of the proxy.</p>

<p><img src="https://media.licdn.com/mpr/mpr/shrinknp_800_800/AAEAAQAAAAAAAAcrAAAAJGIwYzg2YTEzLTg5ZWUtNGZiNC1iMDY2LWE4MTMzNzQwNGU1MQ.png" alt="SharePoint REST API proxy for local serve in Node.js"></p>

<p>Of course, such proxy is limited with REST API only. It can be a complicated task to 're-implement' JSOM, for instance. But as far we go, more and more REST significance we see in SharePoint infrastructure as a universal and language agnostic technology.</p>

<p>The project I created is just a concept, you can <a href="https://github.com/koltyakov/sp-rest-proxy">check in on GitHub</a>. Will see what kind of power will be in SPFx for live communication with a SharePoint instance during workbench debug.</p></body></html>]]></content:encoded></item><item><title><![CDATA[Front-end SharePoint projects  synced and safe!]]></title><description><![CDATA[<html><head></head><body><p>This article is a continuation of my previous one (<a href="/2016/08/25/preparing-development-machine-for-client-side-sharepoint-projects-mac-and-pc/">Preparing development machine for client-side SharePoint projects</a>).</p>

<p>I had stopped on a development machine with all necessary software installed and ready for coding.</p>

<p>And were almost ready, yet, we also desire to skip some scaffolding routines, because somebody did it</p></body></html>]]></description><link>/2016/08/30/front-end-sharepoint-projects-synced-and-safe/</link><guid isPermaLink="false">a5af3ee5-f89f-421f-9cfb-620964eefe2a</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[Gulp]]></category><category><![CDATA[SPSave]]></category><category><![CDATA[SPPull]]></category><category><![CDATA[Yeoman]]></category><category><![CDATA[Toolchain]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Tue, 30 Aug 2016 11:57:00 GMT</pubDate><media:content url="/content/images/2016/09/YoSppp-1.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><img src="/content/images/2016/09/YoSppp-1.png" alt="Front-end SharePoint projects  synced and safe!"><p>This article is a continuation of my previous one (<a href="/2016/08/25/preparing-development-machine-for-client-side-sharepoint-projects-mac-and-pc/">Preparing development machine for client-side SharePoint projects</a>).</p>

<p>I had stopped on a development machine with all necessary software installed and ready for coding.</p>

<p>And were almost ready, yet, we also desire to skip some scaffolding routines, because somebody did it for us.</p>

<p>Have you heard about SharePoint Framework (aka SPFx)? What do they use for delivering project starting point? Yep, they use <a href="http://yeoman.io/">Yeoman generator</a>. But some might say Its too complex for me at the point, I have On-Premises with no Apps configured, I want just edit few assets or My project task is MasterPage-styling-related and I cant achieve anything from SPFx yet.</p>

<p>Thats why for the period of transition from old-style to something brighter, somebody created an alternative for you. Which is simpler to use, which allows mastering Git, VSC (or any), Node.js, tasks right now in a very straightforward way for a very simple but tremendously useful thing.</p>

<p>Here we are. We are going to use <a href="https://www.npmjs.com/package/generator-sppp">SP Pull-n-Push Yeoman Generator</a>. This generator creates a scaffolding project with tasks for pulling files from SharePoint library and saving changed assets to SharePoint back.</p>

<p>Yeoman and some other libraries should have been installed if you followed my previous post. Otherwise, just in case, the command:</p>

<pre><code class="language-bash">npm install -g gulp bower yo  
</code></pre>

<p>Lets install generator next:</p>

<pre><code class="language-bash">npm install -g generator-sppp  
</code></pre>

<blockquote>
  <p>Note: SP Pull-n-Push is young, in case of issues or suggestions all the feedback is welcomed on <a href="https://github.com/koltyakov/generator-sppp/issues">GitHub</a>.</p>
</blockquote>

<p>On new version release Yeoman generators should be updated by running <code>yo</code> command in a console and selecting Update your generators, so you will be using fresh version while scaffolding your next assets project.</p>

<p>To scaffold a project you need to create (or better clone blank project from Git) and run <code>yo</code> command inside a projects directory:</p>

<pre><code class="language-bash">yo sppp [YourProjectName]  
</code></pre>

<p>The generators wizard is executed right away. The wizard asks for project related questions, where you can provide all of the parameters, SharePoint site url and credentials.</p>

<p><img src="http://koltyakov.ru/images/generator-sppp-demo.gif" alt="Front-end SharePoint projects  synced and safe!"></p>

<p>All of the parameters could be changed later on in the project.</p>

<p>The wizard copies files and installs NPM and Bower component if needed.</p>

<p>In current version of this generator there are two tasks:</p>

<p>1. Downloading all the files from target folder in SharePoint to local project <code>./src</code> folder</p>

<p>This task can be useful in some cases. When we need to use existing assets as a start point and too lazy to copy them manually.</p>

<p>The second case is more advanced and consumes Gits capability of detecting the changes. Imagine that some of the assets were changed and this change have been done outside the Git. Thats awful but happens. And we need to have a tool to run a task, wait a bit and see if its ok or if there are some potential issues.</p>

<p>For downloading all files from SharePoint <a href="https://www.npmjs.com/package/sppull">sppull</a> task is there.</p>

<pre><code class="language-bash">gulp sppull-all  
</code></pre>

<p>And, in a while, all the files from SharePoint target are delivered to a local directory for us.</p>

<p>2. The second task is for more often usage. Actually, it should be running everytime we are changing assets in a local project and expecting the changes to be applied to SharePoint.</p>

<pre><code class="language-bash">gulp watch-assets  
</code></pre>

<p>This task starts watching ./src folder and on any change uploads corresponding files straight to a destination. The task uses <a href="https://www.npmjs.com/package/gulp-spsave">gulp-spsave</a> module for Node.js integration with SharePoint.</p>

<p>A project created with the use of sppp yeoman generator could be extended with any other NPM or Bower dependencies and it could be the first step in diving to the new modern way of dealing with SharePoint and transition to SPFx.</p></body></html>]]></content:encoded></item><item><title><![CDATA[Preparing development machine for client-side SharePoint projects (Mac and PC)]]></title><description><![CDATA[<html><head></head><body><blockquote>
  <p>This article is created and could be helpful for those who are planning to develop client-side SharePoint solutions using up-to-date tool sets</p>
</blockquote>

<p>Lets prepare our shiny new and naked development machine from scratch. Were going to use package managers because they are the thing.</p>

<p>Initial installation is slightly</p></body></html>]]></description><link>/2016/08/25/preparing-development-machine-for-client-side-sharepoint-projects-mac-and-pc/</link><guid isPermaLink="false">75433f8a-d597-46b3-b08a-b1979c3ea491</guid><category><![CDATA[SharePoint]]></category><category><![CDATA[Node.js]]></category><category><![CDATA[VSC]]></category><category><![CDATA[Gulp]]></category><category><![CDATA[Toolchain]]></category><category><![CDATA[Yeoman]]></category><category><![CDATA[SPPull]]></category><category><![CDATA[Git]]></category><dc:creator><![CDATA[Andrew Koltyakov]]></dc:creator><pubDate>Thu, 25 Aug 2016 11:35:00 GMT</pubDate><media:content url="/content/images/2016/09/Environment-1.png" medium="image"/><content:encoded><![CDATA[<html><head></head><body><blockquote>
  <img src="/content/images/2016/09/Environment-1.png" alt="Preparing development machine for client-side SharePoint projects (Mac and PC)"><p>This article is created and could be helpful for those who are planning to develop client-side SharePoint solutions using up-to-date tool sets</p>
</blockquote>

<p>Lets prepare our shiny new and naked development machine from scratch. Were going to use package managers because they are the thing.</p>

<p>Initial installation is slightly different on OS X and Windows but the subsequent process of development and capabilities are the same.</p>

<h2 id="softtoinstall">Soft to install</h2>

<p>We need the following tools:</p>

<ul>
<li><a href="https://code.visualstudio.com/">Visual Studio Code</a>  for ninja text editing</li>
<li>Chrome  if your developer position is in any way connected with the word web use this guy, there is nothing better than Chrome Dev Tools then you need to debug or tweak JS or CSS in browser</li>
<li><a href="https://nodejs.org/en/about/">Node.js</a>  its an engine and a heart of development workflow automation</li>
<li>Git client  for source control operations</li>
<li><a href="http://cmder.net/">Cmder</a>  splendid console emulator [for Windows] (Cmd could be used as well or Terminal on Mac OS)</li>
</ul>

<h2 id="windows">Windows</h2>

<h3 id="chocolatey">Chocolatey</h3>

<p>On a PC well get the sugar out of <a href="https://chocolatey.org/">Chocolatey</a>, its a package manager for windows.</p>

<p>Chocolatey installation is as easy as run one-line command in CMD (run as administrator for sure):</p>

<pre><code class="language-bash">@powershell -NoProfile -ExecutionPolicy Bypass -Command "iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))" && SET "PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin"
</code></pre>

<h3 id="packages">Packages</h3>

<p>Here are the benefits, to install all the soft you need it enough to run this (as administrator):</p>

<pre><code class="language-bash">choco install visualstudiocode googlechrome nodejs.install git.install cmder -y  
</code></pre>

<p>Now relax and take your favorite drink. Coffee in my case. =)</p>

<h2 id="osx">OS X</h2>

<h3 id="homebrew">Homebrew</h3>

<p>In a Mac world, <a href="http://brew.sh/">Homebrew</a> is responsible for the same stuff, it extends App Store, as its authors say missing package manager.</p>

<p>One-line command again in Terminal:</p>

<pre><code class="language-bash">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></pre>

<h3 id="packages">Packages</h3>

<p>Time saver is:</p>

<pre><code class="language-bash">brew install node git  
</code></pre>

<p>Unfortunately, there is no formula for Visual Studio Code or Chrome in Homebrew. Chrome could be installed via App Store. VSC has to be downloaded and installed <a href="https://code.visualstudio.com/Download">manually</a>, yet all of this won't take much time.</p>

<h2 id="nodeenvironment">Node environment</h2>

<p>Now were are ready to check the environment by requesting a version for node and its package manager (yeah, one more package manager, this one is used very often) and, of course, Git.</p>

<pre><code class="language-bash">node -v && npm -v && git --version  
</code></pre>

<p>This should return Node.js version, NPM version, then Git version each after another. Commands are combined together and could be split up.</p>

<p>Also, a good point is to check if the VSC is added to Path environment variable. The best option to check if is to navigate somewhere in your file system in the Console/Terminal and type (there should be a space between code and dot):</p>

<pre><code class="language-bash">code .  
</code></pre>

<p>VSC should run with a current folder, where we were in a console, opened.</p>

<p>Before you will be able to use NPM modules, project should be initiated by:</p>

<pre><code class="language-bash">npm init -y  
</code></pre>

<p>This will create package.json in your project folder. Package.json is a definition of the project.</p>

<h3 id="nodemodules">Node modules</h3>

<p>There is a variety of node modules. You can find thousands of them on <a href="https://www.npmjs.com/">NPM site</a>.</p>

<p>Some of the modules could be good, some of them not. So always check the author and community behind the module. As Node application is capable of anything on your machine double check before trust forever.</p>

<p>If you came from .Net world, NPM modules are just like NuGets but for the Node.js.</p>

<p>Modules can be installed globally and locally in the specific project.</p>

<h4 id="globalmodules">Global modules</h4>

<p>Global module installation example:</p>

<pre><code class="language-bash">npm install gulp -g  
</code></pre>

<p>Flag -g corresponds to global, without it installed module will be placed inside node_modules folder inside your project.</p>

<p>Modules that are better to install globally as they going to be used a lot in our projects are:</p>

<ul>
<li><a href="http://gulpjs.com/">gulp</a>  will automate your developers routine</li>
<li><a href="https://bower.io/">bower</a>  yet oh, yet another package manager we need, this one delivers libraries which are used in a browser (such stuff as React, jQuery, Bootstrap, Knockout, well, all your favorite browser libraries)</li>
<li><a href="http://yeoman.io/">yeoman</a>  is a scaffolding tool for creating projects start point</li>
<li><a href="http://eslint.org/">eslint</a>  is a brilliant static code analyzer for JS</li>
<li> lets stop on that right now, dont install too many modules until there is clear understanding why a specific module is needed
OK, so these can be installed with:</li>
</ul>

<pre><code class="language-bash">npm install gulp bower yo eslint -g  
</code></pre>

<h4 id="localmodules">Local modules</h4>

<p>Local modules are a part of your project, dependencies with easily delivering, updating, restoring, that make you reuse communitys efforts and abstract your application.</p>

<p>On most SharePoint assets or lets say it UI development projects, you can benefit from:</p>

<ul>
<li>gulp  you might say Stop its already installed globally, but it also is needed locally (global installation allows to run gulp [task] in a console, but local installation makes its possible to use require(gulp) in a code and define automation tasks)</li>
<li><a href="https://www.npmjs.com/package/spsave">spsave</a> or <a href="https://www.npmjs.com/package/gulp-spsave">gulp-spsave</a>  allow to publish files from local folders to SharePoint document libraries, so there is no need to deploy assets manually</li>
<li><a href="https://www.npmjs.com/package/sppull">sppull</a>  is responsible for downloading existing files from SharePoint programmatically to your project, so you can ensure easily if the project's assets files were changed somehow and have any differences with the Git HEAD using Git Diff algorithm </li>
<li> any other modules depending on the tasks
Before going next, a few words about local modules installation save options.</li>
</ul>

<p>By installing something like:</p>

<pre><code class="language-bash">npm install sppull  
</code></pre>

<p>A module and all its dependencies will be downloaded to node_modules and you will be able to require it in the code, but one thing, if your project is in Git repository you might and should want to exclude modules folder from being stored in your repo.</p>

<p>But its weird to remember all the references then you clone a project from a remote Git repo, thats why --save flag should be used.</p>

<p>So a dependency module installation looks like:</p>

<pre><code class="language-bash">npm install sp-request --save-dev  
</code></pre>

<p>--save-dev adds a module to development dependencies, --save  to production dependencies. The difference is following: --save-dev is applied when a module is used while code creation (it is the support libraries, all that gulp-* libs, sppull, spsave, they help to do stuff when you coding, but they are not included in the project app or dist assets that will be running in SharePoint). For SharePoint UI projects you likely wont need any npm modules to save in prod.</p>

<p>If npm modules were installed with save option later on after cloning or pulling the project, you will need to run npm install and all the references will be downloaded and applied automatically.</p>

<h2 id="bowermodules">Bower modules</h2>

<p>Bower modules concepts and commands are very similar to NPM, the difference is that it manages browsers libraries. Im not going to stop on Bower for long. Lets check the command:</p>

<pre><code class="language-bash">bower install jquery#1.4.1 --save  
</code></pre>

<p>Isnt it identical? In the case of jQuery Im fetching a specific version I need, otherwise, the latest will be downloaded.</p>

<h2 id="git">Git</h2>

<p>Hey, folks! You know a lot about Git, dont you? ;)</p>

<h2 id="finalsteps">Final steps</h2>

<ol>
<li>Create a project in Git (GitHub, BitBucket, Visual Studio Online, no matter)  </li>
<li>git clone [your<em>project</em>url]  </li>
<li>Navigate to your project directory  </li>
<li>NPM init/install: <br>
<ul><li>npm init -y  in the case if it is a new blank project</li>
<li>npm install  in the case of cloning already initiated project from Git
code .  </li></ul></li>
<li>... and, with VSC and console opened, you are ready to rock-n-roll</li>
</ol>

<p>Next time there will be a lot of code and configs, Ill describe project setup for instant publishing to SharePoint and fetching and merging files back from running instance. Hope all of this makes sense. Stay tuned. And welcome to the comment section below.</p></body></html>]]></content:encoded></item></channel></rss>
